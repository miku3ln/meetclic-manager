/*!
  * Bootstrap v5.3.0 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, (function () {
    "use strict";
    const t = new Map, e = {
            set(e, i, n) {
                t.has(e) || t.set(e, new Map);
                const s = t.get(e);
                s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)
            }, get: (e, i) => t.has(e) && t.get(e).get(i) || null, remove(e, i) {
                if (!t.has(e)) return;
                const n = t.get(e);
                n.delete(i), 0 === n.size && t.delete(e)
            }
        }, i = "transitionend",
        n = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t),
        s = t => {
            t.dispatchEvent(new Event(i))
        }, o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
        r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null,
        a = t => {
            if (!o(t) || 0 === t.getClientRects().length) return !1;
            const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
                i = t.closest("details:not([open])");
            if (!i) return e;
            if (i !== t) {
                const e = t.closest("summary");
                if (e && e.parentNode !== i) return !1;
                if (null === e) return !1
            }
            return e
        },
        l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
        c = t => {
            if (!document.documentElement.attachShadow) return null;
            if ("function" == typeof t.getRootNode) {
                const e = t.getRootNode();
                return e instanceof ShadowRoot ? e : null
            }
            return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null
        }, h = () => {
        }, d = t => {
            t.offsetHeight
        }, u = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, f = [],
        p = () => "rtl" === document.documentElement.dir, m = t => {
            var e;
            e = () => {
                const e = u();
                if (e) {
                    const i = t.NAME, n = e.fn[i];
                    e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface)
                }
            }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", (() => {
                for (const t of f) t()
            })), f.push(e)) : e()
        }, g = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i, _ = (t, e, n = !0) => {
            if (!n) return void g(t);
            const o = (t => {
                if (!t) return 0;
                let {transitionDuration: e, transitionDelay: i} = window.getComputedStyle(t);
                const n = Number.parseFloat(e), s = Number.parseFloat(i);
                return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
            })(e) + 5;
            let r = !1;
            const a = ({target: n}) => {
                n === e && (r = !0, e.removeEventListener(i, a), g(t))
            };
            e.addEventListener(i, a), setTimeout((() => {
                r || s(e)
            }), o)
        }, b = (t, e, i, n) => {
            const s = t.length;
            let o = t.indexOf(e);
            return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))])
        }, v = /[^.]*(?=\..*)\.|.*/, y = /\..*/, w = /::\d+$/, A = {};
    let E = 1;
    const T = {mouseenter: "mouseover", mouseleave: "mouseout"},
        C = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function O(t, e) {
        return e && `${e}::${E++}` || t.uidEvent || E++
    }

    function x(t) {
        const e = O(t);
        return t.uidEvent = e, A[e] = A[e] || {}, A[e]
    }

    function k(t, e, i = null) {
        return Object.values(t).find((t => t.callable === e && t.delegationSelector === i))
    }

    function L(t, e, i) {
        const n = "string" == typeof e, s = n ? i : e || i;
        let o = N(t);
        return C.has(o) || (o = t), [n, s, o]
    }

    function S(t, e, i, n, s) {
        if ("string" != typeof e || !t) return;
        let [o, r, a] = L(e, i, n);
        if (e in T) {
            const t = t => function (e) {
                if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
            };
            r = t(r)
        }
        const l = x(t), c = l[a] || (l[a] = {}), h = k(c, r, o ? i : null);
        if (h) return void (h.oneOff = h.oneOff && s);
        const d = O(r, e.replace(v, "")), u = o ? function (t, e, i) {
            return function n(s) {
                const o = t.querySelectorAll(e);
                for (let {target: r} = s; r && r !== this; r = r.parentNode) for (const a of o) if (a === r) return M(s, {delegateTarget: r}), n.oneOff && P.off(t, s.type, e, i), i.apply(r, [s])
            }
        }(t, i, r) : function (t, e) {
            return function i(n) {
                return M(n, {delegateTarget: t}), i.oneOff && P.off(t, n.type, e), e.apply(t, [n])
            }
        }(t, r);
        u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
    }

    function D(t, e, i, n, s) {
        const o = k(e[i], n, s);
        o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent])
    }

    function I(t, e, i, n) {
        const s = e[i] || {};
        for (const [o, r] of Object.entries(s)) o.includes(n) && D(t, e, i, r.callable, r.delegationSelector)
    }

    function N(t) {
        return t = t.replace(y, ""), T[t] || t
    }

    const P = {
        on(t, e, i, n) {
            S(t, e, i, n, !1)
        }, one(t, e, i, n) {
            S(t, e, i, n, !0)
        }, off(t, e, i, n) {
            if ("string" != typeof e || !t) return;
            const [s, o, r] = L(e, i, n), a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith(".");
            if (void 0 === o) {
                if (h) for (const i of Object.keys(l)) I(t, l, i, e.slice(1));
                for (const [i, n] of Object.entries(c)) {
                    const s = i.replace(w, "");
                    a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector)
                }
            } else {
                if (!Object.keys(c).length) return;
                D(t, l, r, o, s ? i : null)
            }
        }, trigger(t, e, i) {
            if ("string" != typeof e || !t) return null;
            const n = u();
            let s = null, o = !0, r = !0, a = !1;
            e !== N(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
            const l = M(new Event(e, {bubbles: o, cancelable: !0}), i);
            return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l
        }
    };

    function M(t, e = {}) {
        for (const [i, n] of Object.entries(e)) try {
            t[i] = n
        } catch (e) {
            Object.defineProperty(t, i, {configurable: !0, get: () => n})
        }
        return t
    }

    function j(t) {
        if ("true" === t) return !0;
        if ("false" === t) return !1;
        if (t === Number(t).toString()) return Number(t);
        if ("" === t || "null" === t) return null;
        if ("string" != typeof t) return t;
        try {
            return JSON.parse(decodeURIComponent(t))
        } catch (e) {
            return t
        }
    }

    function F(t) {
        return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`))
    }

    const H = {
        setDataAttribute(t, e, i) {
            t.setAttribute(`data-bs-${F(e)}`, i)
        }, removeDataAttribute(t, e) {
            t.removeAttribute(`data-bs-${F(e)}`)
        }, getDataAttributes(t) {
            if (!t) return {};
            const e = {}, i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig")));
            for (const n of i) {
                let i = n.replace(/^bs/, "");
                i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = j(t.dataset[n])
            }
            return e
        }, getDataAttribute: (t, e) => j(t.getAttribute(`data-bs-${F(e)}`))
    };

    class ${static get Default(){return{}
}
static
get
DefaultType()
{
    return {}
}
static
get
NAME()
{
    throw new Error('You have to implement the static method "NAME", for each component!')
}
_getConfig(t)
{
    return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
}
_configAfterMerge(t)
{
    return t
}
_mergeConfigObj(t, e)
{
    const i = o(e) ? H.getDataAttribute(e, "config") : {};
    return {...this.constructor.Default, ..."object" == typeof i ? i : {}, ...o(e) ? H.getDataAttributes(e) : {}, ..."object" == typeof t ? t : {}}
}
_typeCheckConfig(t, e = this.constructor.DefaultType)
{
    for (const [n, s] of Object.entries(e)) {
        const e = t[n],
            r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`)
    }
    var i
}
}

class W extends ${constructor(t,i){super(),(t=r(t))&&(this._element=t,this._config=this._getConfig(i),e.set(this._element,this.constructor.DATA_KEY,this))}dispose() {
    e
.

    remove(

    this
.
    _element
,
    this
.
    constructor
.
    DATA_KEY
),
    P
.

    off(

    this
.
    _element
,
    this
.
    constructor
.
    EVENT_KEY
)
    ;

    for(

    const
    t
    of
    Object
.

    getOwnPropertyNames(

    this
))
    this
    [t] = null
}

_queueCallback(t, e, i = !0)
{
    _(t, e, i)
}
_getConfig(t)
{
    return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
}
static
getInstance(t)
{
    return e.get(r(t), this.DATA_KEY)
}
static
getOrCreateInstance(t, e = {})
{
    return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
}
static
get
VERSION()
{
    return "5.3.0"
}
static
get
DATA_KEY()
{
    return `bs.${this.NAME}`
}
static
get
EVENT_KEY()
{
    return `.${this.DATA_KEY}`
}
static
eventName(t)
{
    return `${t}${this.EVENT_KEY}`
}
}
const B = t => {
    let e = t.getAttribute("data-bs-target");
    if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null
    }
    return n(e)
}, z = {
    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
    children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))),
    parents(t, e) {
        const i = [];
        let n = t.parentNode.closest(e);
        for (; n;) i.push(n), n = n.parentNode.closest(e);
        return i
    },
    prev(t, e) {
        let i = t.previousElementSibling;
        for (; i;) {
            if (i.matches(e)) return [i];
            i = i.previousElementSibling
        }
        return []
    },
    next(t, e) {
        let i = t.nextElementSibling;
        for (; i;) {
            if (i.matches(e)) return [i];
            i = i.nextElementSibling
        }
        return []
    },
    focusableChildren(t) {
        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(",");
        return this.find(e, t).filter((t => !l(t) && a(t)))
    },
    getSelectorFromElement(t) {
        const e = B(t);
        return e && z.findOne(e) ? e : null
    },
    getElementFromSelector(t) {
        const e = B(t);
        return e ? z.findOne(e) : null
    },
    getMultipleElementsFromSelector(t) {
        const e = B(t);
        return e ? z.find(e) : []
    }
}, R = (t, e = "hide") => {
    const i = `click.dismiss${t.EVENT_KEY}`, n = t.NAME;
    P.on(document, i, `[data-bs-dismiss="${n}"]`, (function (i) {
        if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return;
        const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
        t.getOrCreateInstance(s)[e]()
    }))
};

class q extends W {
    static get NAME() {
        return "alert"
    }

    close() {
        if (P.trigger(this._element, "close.bs.alert").defaultPrevented) return;
        this._element.classList.remove("show");
        const t = this._element.classList.contains("fade");
        this._queueCallback((() => this._destroyElement()), this._element, t)
    }

    _destroyElement() {
        this._element.remove(), P.trigger(this._element, "closed.bs.alert"), this.dispose()
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = q.getOrCreateInstance(this);
            if ("string" == typeof t) {
                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                e[t](this)
            }
        }))
    }
}

R(q, "close"), m(q);
const V = '[data-bs-toggle="button"]';

class K extends W {
    static get NAME() {
        return "button"
    }

    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = K.getOrCreateInstance(this);
            "toggle" === t && e[t]()
        }))
    }
}

P.on(document, "click.bs.button.data-api", V, (t => {
    t.preventDefault();
    const e = t.target.closest(V);
    K.getOrCreateInstance(e).toggle()
})), m(K);
const Q = {endCallback: null, leftCallback: null, rightCallback: null},
    X = {endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)"};

class Y extends ${constructor(t,e){super(),this._element=t,t&&Y.isSupported()&&(this._config=this._getConfig(e),this._deltaX=0,this._supportPointerEvents=Boolean(window.PointerEvent),this._initEvents())}static

get
Default()
{
    return Q
}
static
get
DefaultType()
{
    return X
}
static
get
NAME()
{
    return "swipe"
}
dispose()
{
    P.off(this._element, ".bs.swipe")
}
_start(t)
{
    this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
}
_end(t)
{
    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback)
}
_move(t)
{
    this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
}
_handleSwipe()
{
    const t = Math.abs(this._deltaX);
    if (t <= 40) return;
    const e = t / this._deltaX;
    this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback)
}
_initEvents()
{
    this._supportPointerEvents ? (P.on(this._element, "pointerdown.bs.swipe", (t => this._start(t))), P.on(this._element, "pointerup.bs.swipe", (t => this._end(t))), this._element.classList.add("pointer-event")) : (P.on(this._element, "touchstart.bs.swipe", (t => this._start(t))), P.on(this._element, "touchmove.bs.swipe", (t => this._move(t))), P.on(this._element, "touchend.bs.swipe", (t => this._end(t))))
}
_eventIsPointerPenTouch(t)
{
    return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
}
static
isSupported()
{
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
}
}
const U = "next", G = "prev", J = "left", Z = "right", tt = "slid.bs.carousel", et = "carousel", it = "active",
    nt = {ArrowLeft: Z, ArrowRight: J},
    st = {interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0}, ot = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };

class rt extends W {
    constructor(t, e) {
        super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === et && this.cycle()
    }

    static get Default() {
        return st
    }

    static get DefaultType() {
        return ot
    }

    static get NAME() {
        return "carousel"
    }

    next() {
        this._slide(U)
    }

    nextWhenVisible() {
        !document.hidden && a(this._element) && this.next()
    }

    prev() {
        this._slide(G)
    }

    pause() {
        this._isSliding && s(this._element), this._clearInterval()
    }

    cycle() {
        this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval)
    }

    _maybeEnableCycle() {
        this._config.ride && (this._isSliding ? P.one(this._element, tt, (() => this.cycle())) : this.cycle())
    }

    to(t) {
        const e = this._getItems();
        if (t > e.length - 1 || t < 0) return;
        if (this._isSliding) return void P.one(this._element, tt, (() => this.to(t)));
        const i = this._getItemIndex(this._getActive());
        if (i === t) return;
        const n = t > i ? U : G;
        this._slide(n, e[t])
    }

    dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
    }

    _configAfterMerge(t) {
        return t.defaultInterval = t.interval, t
    }

    _addEventListeners() {
        this._config.keyboard && P.on(this._element, "keydown.bs.carousel", (t => this._keydown(t))), "hover" === this._config.pause && (P.on(this._element, "mouseenter.bs.carousel", (() => this.pause())), P.on(this._element, "mouseleave.bs.carousel", (() => this._maybeEnableCycle()))), this._config.touch && Y.isSupported() && this._addTouchEventListeners()
    }

    _addTouchEventListeners() {
        for (const t of z.find(".carousel-item img", this._element)) P.on(t, "dragstart.bs.carousel", (t => t.preventDefault()));
        const t = {
            leftCallback: () => this._slide(this._directionToOrder(J)),
            rightCallback: () => this._slide(this._directionToOrder(Z)),
            endCallback: () => {
                "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval))
            }
        };
        this._swipeHelper = new Y(this._element, t)
    }

    _keydown(t) {
        if (/input|textarea/i.test(t.target.tagName)) return;
        const e = nt[t.key];
        e && (t.preventDefault(), this._slide(this._directionToOrder(e)))
    }

    _getItemIndex(t) {
        return this._getItems().indexOf(t)
    }

    _setActiveIndicatorElement(t) {
        if (!this._indicatorsElement) return;
        const e = z.findOne(".active", this._indicatorsElement);
        e.classList.remove(it), e.removeAttribute("aria-current");
        const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
        i && (i.classList.add(it), i.setAttribute("aria-current", "true"))
    }

    _updateInterval() {
        const t = this._activeElement || this._getActive();
        if (!t) return;
        const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
        this._config.interval = e || this._config.defaultInterval
    }

    _slide(t, e = null) {
        if (this._isSliding) return;
        const i = this._getActive(), n = t === U, s = e || b(this._getItems(), i, n, this._config.wrap);
        if (s === i) return;
        const o = this._getItemIndex(s), r = e => P.trigger(this._element, e, {
            relatedTarget: s,
            direction: this._orderToDirection(t),
            from: this._getItemIndex(i),
            to: o
        });
        if (r("slide.bs.carousel").defaultPrevented) return;
        if (!i || !s) return;
        const a = Boolean(this._interval);
        this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
        const l = n ? "carousel-item-start" : "carousel-item-end", c = n ? "carousel-item-next" : "carousel-item-prev";
        s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback((() => {
            s.classList.remove(l, c), s.classList.add(it), i.classList.remove(it, c, l), this._isSliding = !1, r(tt)
        }), i, this._isAnimated()), a && this.cycle()
    }

    _isAnimated() {
        return this._element.classList.contains("slide")
    }

    _getActive() {
        return z.findOne(".active.carousel-item", this._element)
    }

    _getItems() {
        return z.find(".carousel-item", this._element)
    }

    _clearInterval() {
        this._interval && (clearInterval(this._interval), this._interval = null)
    }

    _directionToOrder(t) {
        return p() ? t === J ? G : U : t === J ? U : G
    }

    _orderToDirection(t) {
        return p() ? t === G ? J : Z : t === G ? Z : J
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = rt.getOrCreateInstance(this, t);
            if ("number" != typeof t) {
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            } else e.to(t)
        }))
    }
}

P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", (function (t) {
    const e = z.getElementFromSelector(this);
    if (!e || !e.classList.contains(et)) return;
    t.preventDefault();
    const i = rt.getOrCreateInstance(e), n = this.getAttribute("data-bs-slide-to");
    return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === H.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle())
})), P.on(window, "load.bs.carousel.data-api", (() => {
    const t = z.find('[data-bs-ride="carousel"]');
    for (const e of t) rt.getOrCreateInstance(e)
})), m(rt);
const at = "show", lt = "collapse", ct = "collapsing", ht = '[data-bs-toggle="collapse"]',
    dt = {parent: null, toggle: !0}, ut = {parent: "(null|element)", toggle: "boolean"};

class ft extends W {
    constructor(t, e) {
        super(t, e), this._isTransitioning = !1, this._triggerArray = [];
        const i = z.find(ht);
        for (const t of i) {
            const e = z.getSelectorFromElement(t), i = z.find(e).filter((t => t === this._element));
            null !== e && i.length && this._triggerArray.push(t)
        }
        this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
    }

    static get Default() {
        return dt
    }

    static get DefaultType() {
        return ut
    }

    static get NAME() {
        return "collapse"
    }

    toggle() {
        this._isShown() ? this.hide() : this.show()
    }

    show() {
        if (this._isTransitioning || this._isShown()) return;
        let t = [];
        if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => ft.getOrCreateInstance(t, {toggle: !1})))), t.length && t[0]._isTransitioning) return;
        if (P.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
        for (const e of t) e.hide();
        const e = this._getDimension();
        this._element.classList.remove(lt), this._element.classList.add(ct), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
        const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
        this._queueCallback((() => {
            this._isTransitioning = !1, this._element.classList.remove(ct), this._element.classList.add(lt, at), this._element.style[e] = "", P.trigger(this._element, "shown.bs.collapse")
        }), this._element, !0), this._element.style[e] = `${this._element[i]}px`
    }

    hide() {
        if (this._isTransitioning || !this._isShown()) return;
        if (P.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
        const t = this._getDimension();
        this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(ct), this._element.classList.remove(lt, at);
        for (const t of this._triggerArray) {
            const e = z.getElementFromSelector(t);
            e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1)
        }
        this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => {
            this._isTransitioning = !1, this._element.classList.remove(ct), this._element.classList.add(lt), P.trigger(this._element, "hidden.bs.collapse")
        }), this._element, !0)
    }

    _isShown(t = this._element) {
        return t.classList.contains(at)
    }

    _configAfterMerge(t) {
        return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t
    }

    _getDimension() {
        return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
    }

    _initializeChildren() {
        if (!this._config.parent) return;
        const t = this._getFirstLevelChildren(ht);
        for (const e of t) {
            const t = z.getElementFromSelector(e);
            t && this._addAriaAndCollapsedClass([e], this._isShown(t))
        }
    }

    _getFirstLevelChildren(t) {
        const e = z.find(":scope .collapse .collapse", this._config.parent);
        return z.find(t, this._config.parent).filter((t => !e.includes(t)))
    }

    _addAriaAndCollapsedClass(t, e) {
        if (t.length) for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e)
    }

    static jQueryInterface(t) {
        const e = {};
        return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function () {
            const i = ft.getOrCreateInstance(this, e);
            if ("string" == typeof t) {
                if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        }))
    }
}

P.on(document, "click.bs.collapse.data-api", ht, (function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    for (const t of z.getMultipleElementsFromSelector(this)) ft.getOrCreateInstance(t, {toggle: !1}).toggle()
})), m(ft);
var pt = "top", mt = "bottom", gt = "right", _t = "left", bt = "auto", vt = [pt, mt, gt, _t], yt = "start", wt = "end",
    At = "clippingParents", Et = "viewport", Tt = "popper", Ct = "reference", Ot = vt.reduce((function (t, e) {
        return t.concat([e + "-" + yt, e + "-" + wt])
    }), []), xt = [].concat(vt, [bt]).reduce((function (t, e) {
        return t.concat([e, e + "-" + yt, e + "-" + wt])
    }), []), kt = "beforeRead", Lt = "read", St = "afterRead", Dt = "beforeMain", It = "main", Nt = "afterMain",
    Pt = "beforeWrite", Mt = "write", jt = "afterWrite", Ft = [kt, Lt, St, Dt, It, Nt, Pt, Mt, jt];

function Ht(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function $t(t) {
    if (null == t) return window;
    if ("[object Window]" !== t.toString()) {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function Wt(t) {
    return t instanceof $t(t).Element || t instanceof Element
}

function Bt(t) {
    return t instanceof $t(t).HTMLElement || t instanceof HTMLElement
}

function zt(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof $t(t).ShadowRoot || t instanceof ShadowRoot)
}

const Rt = {
    name: "applyStyles", enabled: !0, phase: "write", fn: function (t) {
        var e = t.state;
        Object.keys(e.elements).forEach((function (t) {
            var i = e.styles[t] || {}, n = e.attributes[t] || {}, s = e.elements[t];
            Bt(s) && Ht(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function (t) {
                var e = n[t];
                !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
            })))
        }))
    }, effect: function (t) {
        var e = t.state, i = {
            popper: {position: e.options.strategy, left: "0", top: "0", margin: "0"},
            arrow: {position: "absolute"},
            reference: {}
        };
        return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function () {
            Object.keys(e.elements).forEach((function (t) {
                var n = e.elements[t], s = e.attributes[t] || {},
                    o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce((function (t, e) {
                        return t[e] = "", t
                    }), {});
                Bt(n) && Ht(n) && (Object.assign(n.style, o), Object.keys(s).forEach((function (t) {
                    n.removeAttribute(t)
                })))
            }))
        }
    }, requires: ["computeStyles"]
};

function qt(t) {
    return t.split("-")[0]
}

var Vt = Math.max, Kt = Math.min, Qt = Math.round;

function Xt() {
    var t = navigator.userAgentData;
    return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map((function (t) {
        return t.brand + "/" + t.version
    })).join(" ") : navigator.userAgent
}

function Yt() {
    return !/^((?!chrome|android).)*safari/i.test(Xt())
}

function Ut(t, e, i) {
    void 0 === e && (e = !1), void 0 === i && (i = !1);
    var n = t.getBoundingClientRect(), s = 1, o = 1;
    e && Bt(t) && (s = t.offsetWidth > 0 && Qt(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Qt(n.height) / t.offsetHeight || 1);
    var r = (Wt(t) ? $t(t) : window).visualViewport, a = !Yt() && i, l = (n.left + (a && r ? r.offsetLeft : 0)) / s,
        c = (n.top + (a && r ? r.offsetTop : 0)) / o, h = n.width / s, d = n.height / o;
    return {width: h, height: d, top: c, right: l + h, bottom: c + d, left: l, x: l, y: c}
}

function Gt(t) {
    var e = Ut(t), i = t.offsetWidth, n = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: i,
        height: n
    }
}

function Jt(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && zt(i)) {
        var n = e;
        do {
            if (n && t.isSameNode(n)) return !0;
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}

function Zt(t) {
    return $t(t).getComputedStyle(t)
}

function te(t) {
    return ["table", "td", "th"].indexOf(Ht(t)) >= 0
}

function ee(t) {
    return ((Wt(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function ie(t) {
    return "html" === Ht(t) ? t : t.assignedSlot || t.parentNode || (zt(t) ? t.host : null) || ee(t)
}

function ne(t) {
    return Bt(t) && "fixed" !== Zt(t).position ? t.offsetParent : null
}

function se(t) {
    for (var e = $t(t), i = ne(t); i && te(i) && "static" === Zt(i).position;) i = ne(i);
    return i && ("html" === Ht(i) || "body" === Ht(i) && "static" === Zt(i).position) ? e : i || function (t) {
        var e = /firefox/i.test(Xt());
        if (/Trident/i.test(Xt()) && Bt(t) && "fixed" === Zt(t).position) return null;
        var i = ie(t);
        for (zt(i) && (i = i.host); Bt(i) && ["html", "body"].indexOf(Ht(i)) < 0;) {
            var n = Zt(i);
            if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
            i = i.parentNode
        }
        return null
    }(t) || e
}

function oe(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function re(t, e, i) {
    return Vt(t, Kt(e, i))
}

function ae(t) {
    return Object.assign({}, {top: 0, right: 0, bottom: 0, left: 0}, t)
}

function le(t, e) {
    return e.reduce((function (e, i) {
        return e[i] = t, e
    }), {})
}

const ce = {
    name: "arrow", enabled: !0, phase: "main", fn: function (t) {
        var e, i = t.state, n = t.name, s = t.options, o = i.elements.arrow, r = i.modifiersData.popperOffsets,
            a = qt(i.placement), l = oe(a), c = [_t, gt].indexOf(a) >= 0 ? "height" : "width";
        if (o && r) {
            var h = function (t, e) {
                    return ae("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {placement: e.placement})) : t) ? t : le(t, vt))
                }(s.padding, i), d = Gt(o), u = "y" === l ? pt : _t, f = "y" === l ? mt : gt,
                p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
                m = r[l] - i.rects.reference[l], g = se(o),
                _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = p / 2 - m / 2, v = h[u],
                y = _ - d[c] - h[f], w = _ / 2 - d[c] / 2 + b, A = re(v, w, y), E = l;
            i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e)
        }
    }, effect: function (t) {
        var e = t.state, i = t.options.element, n = void 0 === i ? "[data-popper-arrow]" : i;
        null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && Jt(e.elements.popper, n) && (e.elements.arrow = n)
    }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"]
};

function he(t) {
    return t.split("-")[1]
}

var de = {top: "auto", right: "auto", bottom: "auto", left: "auto"};

function ue(t) {
    var e, i = t.popper, n = t.popperRect, s = t.placement, o = t.variation, r = t.offsets, a = t.position,
        l = t.gpuAcceleration, c = t.adaptive, h = t.roundOffsets, d = t.isFixed, u = r.x, f = void 0 === u ? 0 : u,
        p = r.y, m = void 0 === p ? 0 : p, g = "function" == typeof h ? h({x: f, y: m}) : {x: f, y: m};
    f = g.x, m = g.y;
    var _ = r.hasOwnProperty("x"), b = r.hasOwnProperty("y"), v = _t, y = pt, w = window;
    if (c) {
        var A = se(i), E = "clientHeight", T = "clientWidth";
        A === $t(i) && "static" !== Zt(A = ee(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === pt || (s === _t || s === gt) && o === wt) && (y = mt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== _t && (s !== pt && s !== mt || o !== wt) || (v = gt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1)
    }
    var C, O = Object.assign({position: a}, c && de), x = !0 === h ? function (t, e) {
        var i = t.x, n = t.y, s = e.devicePixelRatio || 1;
        return {x: Qt(i * s) / s || 0, y: Qt(n * s) / s || 0}
    }({x: f, y: m}, $t(i)) : {x: f, y: m};
    return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e))
}

const fe = {
    name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (t) {
        var e = t.state, i = t.options, n = i.gpuAcceleration, s = void 0 === n || n, o = i.adaptive,
            r = void 0 === o || o, a = i.roundOffsets, l = void 0 === a || a, c = {
                placement: qt(e.placement),
                variation: he(e.placement),
                popper: e.elements.popper,
                popperRect: e.rects.popper,
                gpuAcceleration: s,
                isFixed: "fixed" === e.options.strategy
            };
        null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, ue(Object.assign({}, c, {
            offsets: e.modifiersData.popperOffsets,
            position: e.options.strategy,
            adaptive: r,
            roundOffsets: l
        })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, ue(Object.assign({}, c, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: l
        })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {"data-popper-placement": e.placement})
    }, data: {}
};
var pe = {passive: !0};
const me = {
    name: "eventListeners", enabled: !0, phase: "write", fn: function () {
    }, effect: function (t) {
        var e = t.state, i = t.instance, n = t.options, s = n.scroll, o = void 0 === s || s, r = n.resize,
            a = void 0 === r || r, l = $t(e.elements.popper),
            c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return o && c.forEach((function (t) {
            t.addEventListener("scroll", i.update, pe)
        })), a && l.addEventListener("resize", i.update, pe), function () {
            o && c.forEach((function (t) {
                t.removeEventListener("scroll", i.update, pe)
            })), a && l.removeEventListener("resize", i.update, pe)
        }
    }, data: {}
};
var ge = {left: "right", right: "left", bottom: "top", top: "bottom"};

function _e(t) {
    return t.replace(/left|right|bottom|top/g, (function (t) {
        return ge[t]
    }))
}

var be = {start: "end", end: "start"};

function ve(t) {
    return t.replace(/start|end/g, (function (t) {
        return be[t]
    }))
}

function ye(t) {
    var e = $t(t);
    return {scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset}
}

function we(t) {
    return Ut(ee(t)).left + ye(t).scrollLeft
}

function Ae(t) {
    var e = Zt(t), i = e.overflow, n = e.overflowX, s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n)
}

function Ee(t) {
    return ["html", "body", "#document"].indexOf(Ht(t)) >= 0 ? t.ownerDocument.body : Bt(t) && Ae(t) ? t : Ee(ie(t))
}

function Te(t, e) {
    var i;
    void 0 === e && (e = []);
    var n = Ee(t), s = n === (null == (i = t.ownerDocument) ? void 0 : i.body), o = $t(n),
        r = s ? [o].concat(o.visualViewport || [], Ae(n) ? n : []) : n, a = e.concat(r);
    return s ? a : a.concat(Te(ie(r)))
}

function Ce(t) {
    return Object.assign({}, t, {left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height})
}

function Oe(t, e, i) {
    return e === Et ? Ce(function (t, e) {
        var i = $t(t), n = ee(t), s = i.visualViewport, o = n.clientWidth, r = n.clientHeight, a = 0, l = 0;
        if (s) {
            o = s.width, r = s.height;
            var c = Yt();
            (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop)
        }
        return {width: o, height: r, x: a + we(t), y: l}
    }(t, i)) : Wt(e) ? function (t, e) {
        var i = Ut(t, !1, "fixed" === e);
        return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i
    }(e, i) : Ce(function (t) {
        var e, i = ee(t), n = ye(t), s = null == (e = t.ownerDocument) ? void 0 : e.body,
            o = Vt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
            r = Vt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
            a = -n.scrollLeft + we(t), l = -n.scrollTop;
        return "rtl" === Zt(s || i).direction && (a += Vt(i.clientWidth, s ? s.clientWidth : 0) - o), {
            width: o,
            height: r,
            x: a,
            y: l
        }
    }(ee(t)))
}

function xe(t) {
    var e, i = t.reference, n = t.element, s = t.placement, o = s ? qt(s) : null, r = s ? he(s) : null,
        a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
        case pt:
            e = {x: a, y: i.y - n.height};
            break;
        case mt:
            e = {x: a, y: i.y + i.height};
            break;
        case gt:
            e = {x: i.x + i.width, y: l};
            break;
        case _t:
            e = {x: i.x - n.width, y: l};
            break;
        default:
            e = {x: i.x, y: i.y}
    }
    var c = o ? oe(o) : null;
    if (null != c) {
        var h = "y" === c ? "height" : "width";
        switch (r) {
            case yt:
                e[c] = e[c] - (i[h] / 2 - n[h] / 2);
                break;
            case wt:
                e[c] = e[c] + (i[h] / 2 - n[h] / 2)
        }
    }
    return e
}

function ke(t, e) {
    void 0 === e && (e = {});
    var i = e, n = i.placement, s = void 0 === n ? t.placement : n, o = i.strategy, r = void 0 === o ? t.strategy : o,
        a = i.boundary, l = void 0 === a ? At : a, c = i.rootBoundary, h = void 0 === c ? Et : c, d = i.elementContext,
        u = void 0 === d ? Tt : d, f = i.altBoundary, p = void 0 !== f && f, m = i.padding, g = void 0 === m ? 0 : m,
        _ = ae("number" != typeof g ? g : le(g, vt)), b = u === Tt ? Ct : Tt, v = t.rects.popper,
        y = t.elements[p ? b : u], w = function (t, e, i, n) {
            var s = "clippingParents" === e ? function (t) {
                var e = Te(ie(t)), i = ["absolute", "fixed"].indexOf(Zt(t).position) >= 0 && Bt(t) ? se(t) : t;
                return Wt(i) ? e.filter((function (t) {
                    return Wt(t) && Jt(t, i) && "body" !== Ht(t)
                })) : []
            }(t) : [].concat(e), o = [].concat(s, [i]), r = o[0], a = o.reduce((function (e, i) {
                var s = Oe(t, i, n);
                return e.top = Vt(s.top, e.top), e.right = Kt(s.right, e.right), e.bottom = Kt(s.bottom, e.bottom), e.left = Vt(s.left, e.left), e
            }), Oe(t, r, n));
            return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
        }(Wt(y) ? y : y.contextElement || ee(t.elements.popper), l, h, r), A = Ut(t.elements.reference),
        E = xe({reference: A, element: v, strategy: "absolute", placement: s}), T = Ce(Object.assign({}, v, E)),
        C = u === Tt ? T : A, O = {
            top: w.top - C.top + _.top,
            bottom: C.bottom - w.bottom + _.bottom,
            left: w.left - C.left + _.left,
            right: C.right - w.right + _.right
        }, x = t.modifiersData.offset;
    if (u === Tt && x) {
        var k = x[s];
        Object.keys(O).forEach((function (t) {
            var e = [gt, mt].indexOf(t) >= 0 ? 1 : -1, i = [pt, mt].indexOf(t) >= 0 ? "y" : "x";
            O[t] += k[i] * e
        }))
    }
    return O
}

function Le(t, e) {
    void 0 === e && (e = {});
    var i = e, n = i.placement, s = i.boundary, o = i.rootBoundary, r = i.padding, a = i.flipVariations,
        l = i.allowedAutoPlacements, c = void 0 === l ? xt : l, h = he(n), d = h ? a ? Ot : Ot.filter((function (t) {
            return he(t) === h
        })) : vt, u = d.filter((function (t) {
            return c.indexOf(t) >= 0
        }));
    0 === u.length && (u = d);
    var f = u.reduce((function (e, i) {
        return e[i] = ke(t, {placement: i, boundary: s, rootBoundary: o, padding: r})[qt(i)], e
    }), {});
    return Object.keys(f).sort((function (t, e) {
        return f[t] - f[e]
    }))
}

const Se = {
    name: "flip", enabled: !0, phase: "main", fn: function (t) {
        var e = t.state, i = t.options, n = t.name;
        if (!e.modifiersData[n]._skip) {
            for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = qt(g), b = l || (_ !== g && p ? function (t) {
                if (qt(t) === bt) return [];
                var e = _e(t);
                return [ve(t), e, ve(e)]
            }(g) : [_e(g)]), v = [g].concat(b).reduce((function (t, i) {
                return t.concat(qt(i) === bt ? Le(e, {
                    placement: i,
                    boundary: h,
                    rootBoundary: d,
                    padding: c,
                    flipVariations: p,
                    allowedAutoPlacements: m
                }) : i)
            }), []), y = e.rects.reference, w = e.rects.popper, A = new Map, E = !0, T = v[0], C = 0; C < v.length; C++) {
                var O = v[C], x = qt(O), k = he(O) === yt, L = [pt, mt].indexOf(x) >= 0, S = L ? "width" : "height",
                    D = ke(e, {placement: O, boundary: h, rootBoundary: d, altBoundary: u, padding: c}),
                    I = L ? k ? gt : _t : k ? mt : pt;
                y[S] > w[S] && (I = _e(I));
                var N = _e(I), P = [];
                if (o && P.push(D[x] <= 0), a && P.push(D[I] <= 0, D[N] <= 0), P.every((function (t) {
                    return t
                }))) {
                    T = O, E = !1;
                    break
                }
                A.set(O, P)
            }
            if (E) for (var M = function (t) {
                var e = v.find((function (e) {
                    var i = A.get(e);
                    if (i) return i.slice(0, t).every((function (t) {
                        return t
                    }))
                }));
                if (e) return T = e, "break"
            }, j = p ? 3 : 1; j > 0 && "break" !== M(j); j--) ;
            e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0)
        }
    }, requiresIfExists: ["offset"], data: {_skip: !1}
};

function De(t, e, i) {
    return void 0 === i && (i = {x: 0, y: 0}), {
        top: t.top - e.height - i.y,
        right: t.right - e.width + i.x,
        bottom: t.bottom - e.height + i.y,
        left: t.left - e.width - i.x
    }
}

function Ie(t) {
    return [pt, gt, mt, _t].some((function (e) {
        return t[e] >= 0
    }))
}

const Ne = {
    name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (t) {
        var e = t.state, i = t.name, n = e.rects.reference, s = e.rects.popper, o = e.modifiersData.preventOverflow,
            r = ke(e, {elementContext: "reference"}), a = ke(e, {altBoundary: !0}), l = De(r, n), c = De(a, s, o),
            h = Ie(l), d = Ie(c);
        e.modifiersData[i] = {
            referenceClippingOffsets: l,
            popperEscapeOffsets: c,
            isReferenceHidden: h,
            hasPopperEscaped: d
        }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
            "data-popper-reference-hidden": h,
            "data-popper-escaped": d
        })
    }
}, Pe = {
    name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (t) {
        var e = t.state, i = t.options, n = t.name, s = i.offset, o = void 0 === s ? [0, 0] : s,
            r = xt.reduce((function (t, i) {
                return t[i] = function (t, e, i) {
                    var n = qt(t), s = [_t, pt].indexOf(n) >= 0 ? -1 : 1,
                        o = "function" == typeof i ? i(Object.assign({}, e, {placement: t})) : i, r = o[0], a = o[1];
                    return r = r || 0, a = (a || 0) * s, [_t, gt].indexOf(n) >= 0 ? {x: a, y: r} : {x: r, y: a}
                }(i, e.rects, o), t
            }), {}), a = r[e.placement], l = a.x, c = a.y;
        null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r
    }
}, Me = {
    name: "popperOffsets", enabled: !0, phase: "read", fn: function (t) {
        var e = t.state, i = t.name;
        e.modifiersData[i] = xe({
            reference: e.rects.reference,
            element: e.rects.popper,
            strategy: "absolute",
            placement: e.placement
        })
    }, data: {}
}, je = {
    name: "preventOverflow", enabled: !0, phase: "main", fn: function (t) {
        var e = t.state, i = t.options, n = t.name, s = i.mainAxis, o = void 0 === s || s, r = i.altAxis,
            a = void 0 !== r && r, l = i.boundary, c = i.rootBoundary, h = i.altBoundary, d = i.padding, u = i.tether,
            f = void 0 === u || u, p = i.tetherOffset, m = void 0 === p ? 0 : p,
            g = ke(e, {boundary: l, rootBoundary: c, padding: d, altBoundary: h}), _ = qt(e.placement),
            b = he(e.placement), v = !b, y = oe(_), w = "x" === y ? "y" : "x", A = e.modifiersData.popperOffsets,
            E = e.rects.reference, T = e.rects.popper,
            C = "function" == typeof m ? m(Object.assign({}, e.rects, {placement: e.placement})) : m,
            O = "number" == typeof C ? {mainAxis: C, altAxis: C} : Object.assign({mainAxis: 0, altAxis: 0}, C),
            x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, k = {x: 0, y: 0};
        if (A) {
            if (o) {
                var L, S = "y" === y ? pt : _t, D = "y" === y ? mt : gt, I = "y" === y ? "height" : "width", N = A[y],
                    P = N + g[S], M = N - g[D], j = f ? -T[I] / 2 : 0, F = b === yt ? E[I] : T[I],
                    H = b === yt ? -T[I] : -E[I], $ = e.elements.arrow, W = f && $ ? Gt($) : {width: 0, height: 0},
                    B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, z = B[S], R = B[D], q = re(0, E[I], W[I]),
                    V = v ? E[I] / 2 - j - q - z - O.mainAxis : F - q - z - O.mainAxis,
                    K = v ? -E[I] / 2 + j + q + R + O.mainAxis : H + q + R + O.mainAxis,
                    Q = e.elements.arrow && se(e.elements.arrow),
                    X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0,
                    Y = null != (L = null == x ? void 0 : x[y]) ? L : 0, U = N + K - Y,
                    G = re(f ? Kt(P, N + V - Y - X) : P, N, f ? Vt(M, U) : M);
                A[y] = G, k[y] = G - N
            }
            if (a) {
                var J, Z = "x" === y ? pt : _t, tt = "x" === y ? mt : gt, et = A[w],
                    it = "y" === w ? "height" : "width", nt = et + g[Z], st = et - g[tt],
                    ot = -1 !== [pt, _t].indexOf(_), rt = null != (J = null == x ? void 0 : x[w]) ? J : 0,
                    at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis,
                    lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st, ct = f && ot ? function (t, e, i) {
                        var n = re(t, e, i);
                        return n > i ? i : n
                    }(at, et, lt) : re(f ? at : nt, et, f ? lt : st);
                A[w] = ct, k[w] = ct - et
            }
            e.modifiersData[n] = k
        }
    }, requiresIfExists: ["offset"]
};

function Fe(t, e, i) {
    void 0 === i && (i = !1);
    var n, s, o = Bt(e), r = Bt(e) && function (t) {
        var e = t.getBoundingClientRect(), i = Qt(e.width) / t.offsetWidth || 1, n = Qt(e.height) / t.offsetHeight || 1;
        return 1 !== i || 1 !== n
    }(e), a = ee(e), l = Ut(t, r, i), c = {scrollLeft: 0, scrollTop: 0}, h = {x: 0, y: 0};
    return (o || !o && !i) && (("body" !== Ht(e) || Ae(a)) && (c = (n = e) !== $t(n) && Bt(n) ? {
        scrollLeft: (s = n).scrollLeft,
        scrollTop: s.scrollTop
    } : ye(n)), Bt(e) ? ((h = Ut(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = we(a))), {
        x: l.left + c.scrollLeft - h.x,
        y: l.top + c.scrollTop - h.y,
        width: l.width,
        height: l.height
    }
}

function He(t) {
    var e = new Map, i = new Set, n = [];

    function s(t) {
        i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function (t) {
            if (!i.has(t)) {
                var n = e.get(t);
                n && s(n)
            }
        })), n.push(t)
    }

    return t.forEach((function (t) {
        e.set(t.name, t)
    })), t.forEach((function (t) {
        i.has(t.name) || s(t)
    })), n
}

var $e = {placement: "bottom", modifiers: [], strategy: "absolute"};

function We() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    return !e.some((function (t) {
        return !(t && "function" == typeof t.getBoundingClientRect)
    }))
}

function Be(t) {
    void 0 === t && (t = {});
    var e = t, i = e.defaultModifiers, n = void 0 === i ? [] : i, s = e.defaultOptions, o = void 0 === s ? $e : s;
    return function (t, e, i) {
        void 0 === i && (i = o);
        var s, r, a = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, $e, o),
            modifiersData: {},
            elements: {reference: t, popper: e},
            attributes: {},
            styles: {}
        }, l = [], c = !1, h = {
            state: a, setOptions: function (i) {
                var s = "function" == typeof i ? i(a.options) : i;
                d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
                    reference: Wt(t) ? Te(t) : t.contextElement ? Te(t.contextElement) : [],
                    popper: Te(e)
                };
                var r, c, u = function (t) {
                    var e = He(t);
                    return Ft.reduce((function (t, i) {
                        return t.concat(e.filter((function (t) {
                            return t.phase === i
                        })))
                    }), [])
                }((r = [].concat(n, a.options.modifiers), c = r.reduce((function (t, e) {
                    var i = t[e.name];
                    return t[e.name] = i ? Object.assign({}, i, e, {
                        options: Object.assign({}, i.options, e.options),
                        data: Object.assign({}, i.data, e.data)
                    }) : e, t
                }), {}), Object.keys(c).map((function (t) {
                    return c[t]
                }))));
                return a.orderedModifiers = u.filter((function (t) {
                    return t.enabled
                })), a.orderedModifiers.forEach((function (t) {
                    var e = t.name, i = t.options, n = void 0 === i ? {} : i, s = t.effect;
                    if ("function" == typeof s) {
                        var o = s({state: a, name: e, instance: h, options: n});
                        l.push(o || function () {
                        })
                    }
                })), h.update()
            }, forceUpdate: function () {
                if (!c) {
                    var t = a.elements, e = t.reference, i = t.popper;
                    if (We(e, i)) {
                        a.rects = {
                            reference: Fe(e, se(i), "fixed" === a.options.strategy),
                            popper: Gt(i)
                        }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (t) {
                            return a.modifiersData[t.name] = Object.assign({}, t.data)
                        }));
                        for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {
                            var s = a.orderedModifiers[n], o = s.fn, r = s.options, l = void 0 === r ? {} : r,
                                d = s.name;
                            "function" == typeof o && (a = o({state: a, options: l, name: d, instance: h}) || a)
                        } else a.reset = !1, n = -1
                    }
                }
            }, update: (s = function () {
                return new Promise((function (t) {
                    h.forceUpdate(), t(a)
                }))
            }, function () {
                return r || (r = new Promise((function (t) {
                    Promise.resolve().then((function () {
                        r = void 0, t(s())
                    }))
                }))), r
            }), destroy: function () {
                d(), c = !0
            }
        };
        if (!We(t, e)) return h;

        function d() {
            l.forEach((function (t) {
                return t()
            })), l = []
        }

        return h.setOptions(i).then((function (t) {
            !c && i.onFirstUpdate && i.onFirstUpdate(t)
        })), h
    }
}

var ze = Be(), Re = Be({defaultModifiers: [me, Me, fe, Rt]}),
    qe = Be({defaultModifiers: [me, Me, fe, Rt, Pe, Se, je, ce, Ne]});
const Ve = Object.freeze(Object.defineProperty({
        __proto__: null,
        afterMain: Nt,
        afterRead: St,
        afterWrite: jt,
        applyStyles: Rt,
        arrow: ce,
        auto: bt,
        basePlacements: vt,
        beforeMain: Dt,
        beforeRead: kt,
        beforeWrite: Pt,
        bottom: mt,
        clippingParents: At,
        computeStyles: fe,
        createPopper: qe,
        createPopperBase: ze,
        createPopperLite: Re,
        detectOverflow: ke,
        end: wt,
        eventListeners: me,
        flip: Se,
        hide: Ne,
        left: _t,
        main: It,
        modifierPhases: Ft,
        offset: Pe,
        placements: xt,
        popper: Tt,
        popperGenerator: Be,
        popperOffsets: Me,
        preventOverflow: je,
        read: Lt,
        reference: Ct,
        right: gt,
        start: yt,
        top: pt,
        variationPlacements: Ot,
        viewport: Et,
        write: Mt
    }, Symbol.toStringTag, {value: "Module"})), Ke = "dropdown", Qe = "ArrowUp", Xe = "ArrowDown",
    Ye = "click.bs.dropdown.data-api", Ue = "keydown.bs.dropdown.data-api", Ge = "show",
    Je = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Ze = `${Je}.show`, ti = ".dropdown-menu",
    ei = p() ? "top-end" : "top-start", ii = p() ? "top-start" : "top-end", ni = p() ? "bottom-end" : "bottom-start",
    si = p() ? "bottom-start" : "bottom-end", oi = p() ? "left-start" : "right-start",
    ri = p() ? "right-start" : "left-start", ai = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [0, 2],
        popperConfig: null,
        reference: "toggle"
    }, li = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };

class ci extends W {
    constructor(t, e) {
        super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, ti)[0] || z.prev(this._element, ti)[0] || z.findOne(ti, this._parent), this._inNavbar = this._detectNavbar()
    }

    static get Default() {
        return ai
    }

    static get DefaultType() {
        return li
    }

    static get NAME() {
        return Ke
    }

    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }

    show() {
        if (l(this._element) || this._isShown()) return;
        const t = {relatedTarget: this._element};
        if (!P.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
            if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) P.on(t, "mouseover", h);
            this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ge), this._element.classList.add(Ge), P.trigger(this._element, "shown.bs.dropdown", t)
        }
    }

    hide() {
        if (l(this._element) || !this._isShown()) return;
        const t = {relatedTarget: this._element};
        this._completeHide(t)
    }

    dispose() {
        this._popper && this._popper.destroy(), super.dispose()
    }

    update() {
        this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
    }

    _completeHide(t) {
        if (!P.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
            if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) P.off(t, "mouseover", h);
            this._popper && this._popper.destroy(), this._menu.classList.remove(Ge), this._element.classList.remove(Ge), this._element.setAttribute("aria-expanded", "false"), H.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, "hidden.bs.dropdown", t)
        }
    }

    _getConfig(t) {
        if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ke.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return t
    }

    _createPopper() {
        if (void 0 === Ve) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        let t = this._element;
        "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
        const e = this._getPopperConfig();
        this._popper = qe(t, this._menu, e)
    }

    _isShown() {
        return this._menu.classList.contains(Ge)
    }

    _getPlacement() {
        const t = this._parent;
        if (t.classList.contains("dropend")) return oi;
        if (t.classList.contains("dropstart")) return ri;
        if (t.classList.contains("dropup-center")) return "top";
        if (t.classList.contains("dropdown-center")) return "bottom";
        const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
        return t.classList.contains("dropup") ? e ? ii : ei : e ? si : ni
    }

    _detectNavbar() {
        return null !== this._element.closest(".navbar")
    }

    _getOffset() {
        const {offset: t} = this._config;
        return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
    }

    _getPopperConfig() {
        const t = {
            placement: this._getPlacement(),
            modifiers: [{name: "preventOverflow", options: {boundary: this._config.boundary}}, {
                name: "offset",
                options: {offset: this._getOffset()}
            }]
        };
        return (this._inNavbar || "static" === this._config.display) && (H.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
            name: "applyStyles",
            enabled: !1
        }]), {...t, ...g(this._config.popperConfig, [t])}
    }

    _selectMenuItem({key: t, target: e}) {
        const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => a(t)));
        i.length && b(i, e, t === Xe, !i.includes(e)).focus()
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = ci.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                e[t]()
            }
        }))
    }

    static clearMenus(t) {
        if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
        const e = z.find(Ze);
        for (const i of e) {
            const e = ci.getInstance(i);
            if (!e || !1 === e._config.autoClose) continue;
            const n = t.composedPath(), s = n.includes(e._menu);
            if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
            if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
            const o = {relatedTarget: e._element};
            "click" === t.type && (o.clickEvent = t), e._completeHide(o)
        }
    }

    static dataApiKeydownHandler(t) {
        const e = /input|textarea/i.test(t.target.tagName), i = "Escape" === t.key, n = [Qe, Xe].includes(t.key);
        if (!n && !i) return;
        if (e && !i) return;
        t.preventDefault();
        const s = this.matches(Je) ? this : z.prev(this, Je)[0] || z.next(this, Je)[0] || z.findOne(Je, t.delegateTarget.parentNode),
            o = ci.getOrCreateInstance(s);
        if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
        o._isShown() && (t.stopPropagation(), o.hide(), s.focus())
    }
}

P.on(document, Ue, Je, ci.dataApiKeydownHandler), P.on(document, Ue, ti, ci.dataApiKeydownHandler), P.on(document, Ye, ci.clearMenus), P.on(document, "keyup.bs.dropdown.data-api", ci.clearMenus), P.on(document, Ye, Je, (function (t) {
    t.preventDefault(), ci.getOrCreateInstance(this).toggle()
})), m(ci);
const hi = "show", di = "mousedown.bs.backdrop",
    ui = {className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body"}, fi = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };

class pi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isAppended=!1,this._element=null}static

get
Default()
{
    return ui
}
static
get
DefaultType()
{
    return fi
}
static
get
NAME()
{
    return "backdrop"
}
show(t)
{
    if (!this._config.isVisible) return void g(t);
    this._append();
    const e = this._getElement();
    this._config.isAnimated && d(e), e.classList.add(hi), this._emulateAnimation((() => {
        g(t)
    }))
}
hide(t)
{
    this._config.isVisible ? (this._getElement().classList.remove(hi), this._emulateAnimation((() => {
        this.dispose(), g(t)
    }))) : g(t)
}
dispose()
{
    this._isAppended && (P.off(this._element, di), this._element.remove(), this._isAppended = !1)
}
_getElement()
{
    if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t
    }
    return this._element
}
_configAfterMerge(t)
{
    return t.rootElement = r(t.rootElement), t
}
_append()
{
    if (this._isAppended) return;
    const t = this._getElement();
    this._config.rootElement.append(t), P.on(t, di, (() => {
        g(this._config.clickCallback)
    })), this._isAppended = !0
}
_emulateAnimation(t)
{
    _(t, this._getElement(), this._config.isAnimated)
}
}
const mi = ".bs.focustrap", gi = "backward", _i = {autofocus: !0, trapElement: null},
    bi = {autofocus: "boolean", trapElement: "element"};

class vi extends ${constructor(t){super(),this._config=this._getConfig(t),this._isActive=!1,this._lastTabNavDirection=null}static

get
Default()
{
    return _i
}
static
get
DefaultType()
{
    return bi
}
static
get
NAME()
{
    return "focustrap"
}
activate()
{
    this._isActive || (this._config.autofocus && this._config.trapElement.focus(), P.off(document, mi), P.on(document, "focusin.bs.focustrap", (t => this._handleFocusin(t))), P.on(document, "keydown.tab.bs.focustrap", (t => this._handleKeydown(t))), this._isActive = !0)
}
deactivate()
{
    this._isActive && (this._isActive = !1, P.off(document, mi))
}
_handleFocusin(t)
{
    const {trapElement: e} = this._config;
    if (t.target === document || t.target === e || e.contains(t.target)) return;
    const i = z.focusableChildren(e);
    0 === i.length ? e.focus() : this._lastTabNavDirection === gi ? i[i.length - 1].focus() : i[0].focus()
}
_handleKeydown(t)
{
    "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? gi : "forward")
}
}
const yi = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", wi = ".sticky-top", Ai = "padding-right",
    Ei = "margin-right";

class Ti {
    constructor() {
        this._element = document.body
    }

    getWidth() {
        const t = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - t)
    }

    hide() {
        const t = this.getWidth();
        this._disableOverFlow(), this._setElementAttributes(this._element, Ai, (e => e + t)), this._setElementAttributes(yi, Ai, (e => e + t)), this._setElementAttributes(wi, Ei, (e => e - t))
    }

    reset() {
        this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Ai), this._resetElementAttributes(yi, Ai), this._resetElementAttributes(wi, Ei)
    }

    isOverflowing() {
        return this.getWidth() > 0
    }

    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
    }

    _setElementAttributes(t, e, i) {
        const n = this.getWidth();
        this._applyManipulationCallback(t, (t => {
            if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
            this._saveInitialAttribute(t, e);
            const s = window.getComputedStyle(t).getPropertyValue(e);
            t.style.setProperty(e, `${i(Number.parseFloat(s))}px`)
        }))
    }

    _saveInitialAttribute(t, e) {
        const i = t.style.getPropertyValue(e);
        i && H.setDataAttribute(t, e, i)
    }

    _resetElementAttributes(t, e) {
        this._applyManipulationCallback(t, (t => {
            const i = H.getDataAttribute(t, e);
            null !== i ? (H.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e)
        }))
    }

    _applyManipulationCallback(t, e) {
        if (o(t)) e(t); else for (const i of z.find(t, this._element)) e(i)
    }
}

const Ci = ".bs.modal", Oi = "hidden.bs.modal", xi = "show.bs.modal", ki = "modal-open", Li = "show",
    Si = "modal-static", Di = {backdrop: !0, focus: !0, keyboard: !0},
    Ii = {backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean"};

class Ni extends W {
    constructor(t, e) {
        super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ti, this._addEventListeners()
    }

    static get Default() {
        return Di
    }

    static get DefaultType() {
        return Ii
    }

    static get NAME() {
        return "modal"
    }

    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }

    show(t) {
        this._isShown || this._isTransitioning || P.trigger(this._element, xi, {relatedTarget: t}).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(ki), this._adjustDialog(), this._backdrop.show((() => this._showElement(t))))
    }

    hide() {
        this._isShown && !this._isTransitioning && (P.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Li), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated())))
    }

    dispose() {
        P.off(window, Ci), P.off(this._dialog, Ci), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }

    handleUpdate() {
        this._adjustDialog()
    }

    _initializeBackDrop() {
        return new pi({isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated()})
    }

    _initializeFocusTrap() {
        return new vi({trapElement: this._element})
    }

    _showElement(t) {
        document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
        const e = z.findOne(".modal-body", this._dialog);
        e && (e.scrollTop = 0), d(this._element), this._element.classList.add(Li), this._queueCallback((() => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, P.trigger(this._element, "shown.bs.modal", {relatedTarget: t})
        }), this._dialog, this._isAnimated())
    }

    _addEventListeners() {
        P.on(this._element, "keydown.dismiss.bs.modal", (t => {
            "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
        })), P.on(window, "resize.bs.modal", (() => {
            this._isShown && !this._isTransitioning && this._adjustDialog()
        })), P.on(this._element, "mousedown.dismiss.bs.modal", (t => {
            P.one(this._element, "click.dismiss.bs.modal", (e => {
                this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
            }))
        }))
    }

    _hideModal() {
        this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => {
            document.body.classList.remove(ki), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, Oi)
        }))
    }

    _isAnimated() {
        return this._element.classList.contains("fade")
    }

    _triggerBackdropTransition() {
        if (P.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
        const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._element.style.overflowY;
        "hidden" === e || this._element.classList.contains(Si) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Si), this._queueCallback((() => {
            this._element.classList.remove(Si), this._queueCallback((() => {
                this._element.style.overflowY = e
            }), this._dialog)
        }), this._dialog), this._element.focus())
    }

    _adjustDialog() {
        const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(),
            i = e > 0;
        if (i && !t) {
            const t = p() ? "paddingLeft" : "paddingRight";
            this._element.style[t] = `${e}px`
        }
        if (!i && t) {
            const t = p() ? "paddingRight" : "paddingLeft";
            this._element.style[t] = `${e}px`
        }
    }

    _resetAdjustments() {
        this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
    }

    static jQueryInterface(t, e) {
        return this.each((function () {
            const i = Ni.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                i[t](e)
            }
        }))
    }
}

P.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (t) {
    const e = z.getElementFromSelector(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), P.one(e, xi, (t => {
        t.defaultPrevented || P.one(e, Oi, (() => {
            a(this) && this.focus()
        }))
    }));
    const i = z.findOne(".modal.show");
    i && Ni.getInstance(i).hide(), Ni.getOrCreateInstance(e).toggle(this)
})), R(Ni), m(Ni);
const Pi = "show", Mi = "showing", ji = "hiding", Fi = ".offcanvas.show", Hi = "hidePrevented.bs.offcanvas",
    $i = "hidden.bs.offcanvas", Wi = {backdrop: !0, keyboard: !0, scroll: !1},
    Bi = {backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean"};

class zi extends W {
    constructor(t, e) {
        super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
    }

    static get Default() {
        return Wi
    }

    static get DefaultType() {
        return Bi
    }

    static get NAME() {
        return "offcanvas"
    }

    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }

    show(t) {
        this._isShown || P.trigger(this._element, "show.bs.offcanvas", {relatedTarget: t}).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Ti).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Mi), this._queueCallback((() => {
            this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Pi), this._element.classList.remove(Mi), P.trigger(this._element, "shown.bs.offcanvas", {relatedTarget: t})
        }), this._element, !0))
    }

    hide() {
        this._isShown && (P.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(ji), this._backdrop.hide(), this._queueCallback((() => {
            this._element.classList.remove(Pi, ji), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new Ti).reset(), P.trigger(this._element, $i)
        }), this._element, !0)))
    }

    dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }

    _initializeBackDrop() {
        const t = Boolean(this._config.backdrop);
        return new pi({
            className: "offcanvas-backdrop",
            isVisible: t,
            isAnimated: !0,
            rootElement: this._element.parentNode,
            clickCallback: t ? () => {
                "static" !== this._config.backdrop ? this.hide() : P.trigger(this._element, Hi)
            } : null
        })
    }

    _initializeFocusTrap() {
        return new vi({trapElement: this._element})
    }

    _addEventListeners() {
        P.on(this._element, "keydown.dismiss.bs.offcanvas", (t => {
            "Escape" === t.key && (this._config.keyboard ? this.hide() : P.trigger(this._element, Hi))
        }))
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = zi.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                e[t](this)
            }
        }))
    }
}

P.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function (t) {
    const e = z.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)) return;
    P.one(e, $i, (() => {
        a(this) && this.focus()
    }));
    const i = z.findOne(Fi);
    i && i !== e && zi.getInstance(i).hide(), zi.getOrCreateInstance(e).toggle(this)
})), P.on(window, "load.bs.offcanvas.data-api", (() => {
    for (const t of z.find(Fi)) zi.getOrCreateInstance(t).show()
})), P.on(window, "resize.bs.offcanvas", (() => {
    for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && zi.getOrCreateInstance(t).hide()
})), R(zi), m(zi);
const Ri = {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }, qi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    Vi = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Ki = (t, e) => {
        const i = t.nodeName.toLowerCase();
        return e.includes(i) ? !qi.has(i) || Boolean(Vi.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(i)))
    }, Qi = {allowList: Ri, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>"},
    Xi = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }, Yi = {entry: "(string|element|function|null)", selector: "(string|element)"};

class Ui extends ${constructor(t){super(),this._config=this._getConfig(t)}static

get
Default()
{
    return Qi
}
static
get
DefaultType()
{
    return Xi
}
static
get
NAME()
{
    return "TemplateFactory"
}
getContent()
{
    return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean)
}
hasContent()
{
    return this.getContent().length > 0
}
changeContent(t)
{
    return this._checkContent(t), this._config.content = {...this._config.content, ...t}, this
}
toHtml()
{
    const t = document.createElement("div");
    t.innerHTML = this._maybeSanitize(this._config.template);
    for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
    const e = t.children[0], i = this._resolvePossibleFunction(this._config.extraClass);
    return i && e.classList.add(...i.split(" ")), e
}
_typeCheckConfig(t)
{
    super._typeCheckConfig(t), this._checkContent(t.content)
}
_checkContent(t)
{
    for (const [e, i] of Object.entries(t)) super._typeCheckConfig({selector: e, entry: i}, Yi)
}
_setContent(t, e, i)
{
    const n = z.findOne(i, t);
    n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove())
}
_maybeSanitize(t)
{
    return this._config.sanitize ? function (t, e, i) {
        if (!t.length) return t;
        if (i && "function" == typeof i) return i(t);
        const n = (new window.DOMParser).parseFromString(t, "text/html"),
            s = [].concat(...n.body.querySelectorAll("*"));
        for (const t of s) {
            const i = t.nodeName.toLowerCase();
            if (!Object.keys(e).includes(i)) {
                t.remove();
                continue
            }
            const n = [].concat(...t.attributes), s = [].concat(e["*"] || [], e[i] || []);
            for (const e of n) Ki(e, s) || t.removeAttribute(e.nodeName)
        }
        return n.body.innerHTML
    }(t, this._config.allowList, this._config.sanitizeFn) : t
}
_resolvePossibleFunction(t)
{
    return g(t, [this])
}
_putElementInTemplate(t, e)
{
    if (this._config.html) return e.innerHTML = "", void e.append(t);
    e.textContent = t.textContent
}
}
const Gi = new Set(["sanitize", "allowList", "sanitizeFn"]), Ji = "fade", Zi = "show", tn = ".modal",
    en = "hide.bs.modal", nn = "hover", sn = "focus",
    on = {AUTO: "auto", TOP: "top", RIGHT: p() ? "left" : "right", BOTTOM: "bottom", LEFT: p() ? "right" : "left"},
    rn = {
        allowList: Ri,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 6],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }, an = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };

class ln extends W {
    constructor(t, e) {
        if (void 0 === Ve) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()
    }

    static get Default() {
        return rn
    }

    static get DefaultType() {
        return an
    }

    static get NAME() {
        return "tooltip"
    }

    enable() {
        this._isEnabled = !0
    }

    disable() {
        this._isEnabled = !1
    }

    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }

    toggle() {
        this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter())
    }

    dispose() {
        clearTimeout(this._timeout), P.off(this._element.closest(tn), en, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose()
    }

    show() {
        if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
        if (!this._isWithContent() || !this._isEnabled) return;
        const t = P.trigger(this._element, this.constructor.eventName("show")),
            e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
        if (t.defaultPrevented || !e) return;
        this._disposePopper();
        const i = this._getTipElement();
        this._element.setAttribute("aria-describedby", i.getAttribute("id"));
        const {container: n} = this._config;
        if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), P.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(Zi), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) P.on(t, "mouseover", h);
        this._queueCallback((() => {
            P.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1
        }), this.tip, this._isAnimated())
    }

    hide() {
        if (this._isShown() && !P.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
            if (this._getTipElement().classList.remove(Zi), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) P.off(t, "mouseover", h);
            this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this._isHovered = null, this._queueCallback((() => {
                this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), P.trigger(this._element, this.constructor.eventName("hidden")))
            }), this.tip, this._isAnimated())
        }
    }

    update() {
        this._popper && this._popper.update()
    }

    _isWithContent() {
        return Boolean(this._getTitle())
    }

    _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
    }

    _createTipElement(t) {
        const e = this._getTemplateFactory(t).toHtml();
        if (!e) return null;
        e.classList.remove(Ji, Zi), e.classList.add(`bs-${this.constructor.NAME}-auto`);
        const i = (t => {
            do {
                t += Math.floor(1e6 * Math.random())
            } while (document.getElementById(t));
            return t
        })(this.constructor.NAME).toString();
        return e.setAttribute("id", i), this._isAnimated() && e.classList.add(Ji), e
    }

    setContent(t) {
        this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
    }

    _getTemplateFactory(t) {
        return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Ui({
            ...this._config,
            content: t,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
        }), this._templateFactory
    }

    _getContentForTemplate() {
        return {".tooltip-inner": this._getTitle()}
    }

    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
    }

    _initializeOnDelegatedTarget(t) {
        return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
    }

    _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(Ji)
    }

    _isShown() {
        return this.tip && this.tip.classList.contains(Zi)
    }

    _createPopper(t) {
        const e = g(this._config.placement, [this, t, this._element]), i = on[e.toUpperCase()];
        return qe(this._element, t, this._getPopperConfig(i))
    }

    _getOffset() {
        const {offset: t} = this._config;
        return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
    }

    _resolvePossibleFunction(t) {
        return g(t, [this._element])
    }

    _getPopperConfig(t) {
        const e = {
            placement: t,
            modifiers: [{name: "flip", options: {fallbackPlacements: this._config.fallbackPlacements}}, {
                name: "offset",
                options: {offset: this._getOffset()}
            }, {name: "preventOverflow", options: {boundary: this._config.boundary}}, {
                name: "arrow",
                options: {element: `.${this.constructor.NAME}-arrow`}
            }, {
                name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: t => {
                    this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
                }
            }]
        };
        return {...e, ...g(this._config.popperConfig, [e])}
    }

    _setListeners() {
        const t = this._config.trigger.split(" ");
        for (const e of t) if ("click" === e) P.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => {
            this._initializeOnDelegatedTarget(t).toggle()
        })); else if ("manual" !== e) {
            const t = e === nn ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
                i = e === nn ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
            P.on(this._element, t, this._config.selector, (t => {
                const e = this._initializeOnDelegatedTarget(t);
                e._activeTrigger["focusin" === t.type ? sn : nn] = !0, e._enter()
            })), P.on(this._element, i, this._config.selector, (t => {
                const e = this._initializeOnDelegatedTarget(t);
                e._activeTrigger["focusout" === t.type ? sn : nn] = e._element.contains(t.relatedTarget), e._leave()
            }))
        }
        this._hideModalHandler = () => {
            this._element && this.hide()
        }, P.on(this._element.closest(tn), en, this._hideModalHandler)
    }

    _fixTitle() {
        const t = this._element.getAttribute("title");
        t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"))
    }

    _enter() {
        this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => {
            this._isHovered && this.show()
        }), this._config.delay.show))
    }

    _leave() {
        this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => {
            this._isHovered || this.hide()
        }), this._config.delay.hide))
    }

    _setTimeout(t, e) {
        clearTimeout(this._timeout), this._timeout = setTimeout(t, e)
    }

    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0)
    }

    _getConfig(t) {
        const e = H.getDataAttributes(this._element);
        for (const t of Object.keys(e)) Gi.has(t) && delete e[t];
        return t = {...e, ..."object" == typeof t && t ? t : {}}, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }

    _configAfterMerge(t) {
        return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
            show: t.delay,
            hide: t.delay
        }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t
    }

    _getDelegateConfig() {
        const t = {};
        for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i);
        return t.selector = !1, t.trigger = "manual", t
    }

    _disposePopper() {
        this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null)
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = ln.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                e[t]()
            }
        }))
    }
}

m(ln);
const cn = {
    ...ln.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
}, hn = {...ln.DefaultType, content: "(null|string|element|function)"};

class dn extends ln {
    static get Default() {
        return cn
    }

    static get DefaultType() {
        return hn
    }

    static get NAME() {
        return "popover"
    }

    _isWithContent() {
        return this._getTitle() || this._getContent()
    }

    _getContentForTemplate() {
        return {".popover-header": this._getTitle(), ".popover-body": this._getContent()}
    }

    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = dn.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                e[t]()
            }
        }))
    }
}

m(dn);
const un = "click.bs.scrollspy", fn = "active", pn = "[href]",
    mn = {offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1]}, gn = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };

class _n extends W {
    constructor(t, e) {
        super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
        }, this.refresh()
    }

    static get Default() {
        return mn
    }

    static get DefaultType() {
        return gn
    }

    static get NAME() {
        return "scrollspy"
    }

    refresh() {
        this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
        for (const t of this._observableSections.values()) this._observer.observe(t)
    }

    dispose() {
        this._observer.disconnect(), super.dispose()
    }

    _configAfterMerge(t) {
        return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t
    }

    _maybeEnableSmoothScroll() {
        this._config.smoothScroll && (P.off(this._config.target, un), P.on(this._config.target, un, pn, (t => {
            const e = this._observableSections.get(t.target.hash);
            if (e) {
                t.preventDefault();
                const i = this._rootElement || window, n = e.offsetTop - this._element.offsetTop;
                if (i.scrollTo) return void i.scrollTo({top: n, behavior: "smooth"});
                i.scrollTop = n
            }
        })))
    }

    _getNewObserver() {
        const t = {root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin};
        return new IntersectionObserver((t => this._observerCallback(t)), t)
    }

    _observerCallback(t) {
        const e = t => this._targetLinks.get(`#${t.target.id}`), i = t => {
                this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t))
            }, n = (this._rootElement || document.documentElement).scrollTop,
            s = n >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = n;
        for (const o of t) {
            if (!o.isIntersecting) {
                this._activeTarget = null, this._clearActiveClass(e(o));
                continue
            }
            const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (s && t) {
                if (i(o), !n) return
            } else s || t || i(o)
        }
    }

    _initializeTargetsAndObservables() {
        this._targetLinks = new Map, this._observableSections = new Map;
        const t = z.find(pn, this._config.target);
        for (const e of t) {
            if (!e.hash || l(e)) continue;
            const t = z.findOne(decodeURI(e.hash), this._element);
            a(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t))
        }
    }

    _process(t) {
        this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(fn), this._activateParents(t), P.trigger(this._element, "activate.bs.scrollspy", {relatedTarget: t}))
    }

    _activateParents(t) {
        if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(fn); else for (const e of z.parents(t, ".nav, .list-group")) for (const t of z.prev(e, ".nav-link, .nav-item > .nav-link, .list-group-item")) t.classList.add(fn)
    }

    _clearActiveClass(t) {
        t.classList.remove(fn);
        const e = z.find("[href].active", t);
        for (const t of e) t.classList.remove(fn)
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = _n.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                e[t]()
            }
        }))
    }
}

P.on(window, "load.bs.scrollspy.data-api", (() => {
    for (const t of z.find('[data-bs-spy="scroll"]')) _n.getOrCreateInstance(t)
})), m(_n);
const bn = "ArrowLeft", vn = "ArrowRight", yn = "ArrowUp", wn = "ArrowDown", An = "active", En = "fade", Tn = "show",
    Cn = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    On = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Cn}`;

class xn extends W {
    constructor(t) {
        super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), P.on(this._element, "keydown.bs.tab", (t => this._keydown(t))))
    }

    static get NAME() {
        return "tab"
    }

    show() {
        const t = this._element;
        if (this._elemIsActive(t)) return;
        const e = this._getActiveElem(), i = e ? P.trigger(e, "hide.bs.tab", {relatedTarget: t}) : null;
        P.trigger(t, "show.bs.tab", {relatedTarget: e}).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e))
    }

    _activate(t, e) {
        t && (t.classList.add(An), this._activate(z.getElementFromSelector(t)), this._queueCallback((() => {
            "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), P.trigger(t, "shown.bs.tab", {relatedTarget: e})) : t.classList.add(Tn)
        }), t, t.classList.contains(En)))
    }

    _deactivate(t, e) {
        t && (t.classList.remove(An), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback((() => {
            "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), P.trigger(t, "hidden.bs.tab", {relatedTarget: e})) : t.classList.remove(Tn)
        }), t, t.classList.contains(En)))
    }

    _keydown(t) {
        if (![bn, vn, yn, wn].includes(t.key)) return;
        t.stopPropagation(), t.preventDefault();
        const e = [vn, wn].includes(t.key), i = b(this._getChildren().filter((t => !l(t))), t.target, e, !0);
        i && (i.focus({preventScroll: !0}), xn.getOrCreateInstance(i).show())
    }

    _getChildren() {
        return z.find(On, this._parent)
    }

    _getActiveElem() {
        return this._getChildren().find((t => this._elemIsActive(t))) || null
    }

    _setInitialAttributes(t, e) {
        this._setAttributeIfNotExists(t, "role", "tablist");
        for (const t of e) this._setInitialAttributesOnChild(t)
    }

    _setInitialAttributesOnChild(t) {
        t = this._getInnerElement(t);
        const e = this._elemIsActive(t), i = this._getOuterElement(t);
        t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
    }

    _setInitialAttributesOnTargetPanel(t) {
        const e = z.getElementFromSelector(t);
        e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`))
    }

    _toggleDropDown(t, e) {
        const i = this._getOuterElement(t);
        if (!i.classList.contains("dropdown")) return;
        const n = (t, n) => {
            const s = z.findOne(t, i);
            s && s.classList.toggle(n, e)
        };
        n(".dropdown-toggle", An), n(".dropdown-menu", Tn), i.setAttribute("aria-expanded", e)
    }

    _setAttributeIfNotExists(t, e, i) {
        t.hasAttribute(e) || t.setAttribute(e, i)
    }

    _elemIsActive(t) {
        return t.classList.contains(An)
    }

    _getInnerElement(t) {
        return t.matches(On) ? t : z.findOne(On, t)
    }

    _getOuterElement(t) {
        return t.closest(".nav-item, .list-group-item") || t
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = xn.getOrCreateInstance(this);
            if ("string" == typeof t) {
                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                e[t]()
            }
        }))
    }
}

P.on(document, "click.bs.tab", Cn, (function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || xn.getOrCreateInstance(this).show()
})), P.on(window, "load.bs.tab", (() => {
    for (const t of z.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) xn.getOrCreateInstance(t)
})), m(xn);
const kn = "hide", Ln = "show", Sn = "showing", Dn = {animation: "boolean", autohide: "boolean", delay: "number"},
    In = {animation: !0, autohide: !0, delay: 5e3};

class Nn extends W {
    constructor(t, e) {
        super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
    }

    static get Default() {
        return In
    }

    static get DefaultType() {
        return Dn
    }

    static get NAME() {
        return "toast"
    }

    show() {
        P.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(kn), d(this._element), this._element.classList.add(Ln, Sn), this._queueCallback((() => {
            this._element.classList.remove(Sn), P.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
        }), this._element, this._config.animation))
    }

    hide() {
        this.isShown() && (P.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(Sn), this._queueCallback((() => {
            this._element.classList.add(kn), this._element.classList.remove(Sn, Ln), P.trigger(this._element, "hidden.bs.toast")
        }), this._element, this._config.animation)))
    }

    dispose() {
        this._clearTimeout(), this.isShown() && this._element.classList.remove(Ln), super.dispose()
    }

    isShown() {
        return this._element.classList.contains(Ln)
    }

    _maybeScheduleHide() {
        this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => {
            this.hide()
        }), this._config.delay)))
    }

    _onInteraction(t, e) {
        switch (t.type) {
            case"mouseover":
            case"mouseout":
                this._hasMouseInteraction = e;
                break;
            case"focusin":
            case"focusout":
                this._hasKeyboardInteraction = e
        }
        if (e) return void this._clearTimeout();
        const i = t.relatedTarget;
        this._element === i || this._element.contains(i) || this._maybeScheduleHide()
    }

    _setListeners() {
        P.on(this._element, "mouseover.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "mouseout.bs.toast", (t => this._onInteraction(t, !1))), P.on(this._element, "focusin.bs.toast", (t => this._onInteraction(t, !0))), P.on(this._element, "focusout.bs.toast", (t => this._onInteraction(t, !1)))
    }

    _clearTimeout() {
        clearTimeout(this._timeout), this._timeout = null
    }

    static jQueryInterface(t) {
        return this.each((function () {
            const e = Nn.getOrCreateInstance(this, t);
            if ("string" == typeof t) {
                if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                e[t](this)
            }
        }))
    }
}

return R(Nn), m(Nn), {
    Alert: q,
    Button: K,
    Carousel: rt,
    Collapse: ft,
    Dropdown: ci,
    Modal: Ni,
    Offcanvas: zi,
    Popover: dn,
    ScrollSpy: _n,
    Tab: xn,
    Toast: Nn,
    Tooltip: ln
}
}))
;
//# sourceMappingURL=bootstrap.bundle.min.js.map
/**
 * SimpleBar.js - v5.1.0
 * Scrollbars, simpler.
 * https://grsmto.github.io/simplebar/
 *
 * Made by Adrien Denat from a fork by Jonathan Nicol
 * Under MIT License
 */

!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).SimpleBar = e()
}(this, (function () {
    "use strict";
    var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function e(t, e) {
        return t(e = {exports: {}}, e.exports), e.exports
    }

    var r, n, i, o = "object", s = function (t) {
            return t && t.Math == Math && t
        },
        a = s(typeof globalThis == o && globalThis) || s(typeof window == o && window) || s(typeof self == o && self) || s(typeof t == o && t) || Function("return this")(),
        c = function (t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }, l = !c((function () {
            return 7 != Object.defineProperty({}, "a", {
                get: function () {
                    return 7
                }
            }).a
        })), u = {}.propertyIsEnumerable, f = Object.getOwnPropertyDescriptor, h = {
            f: f && !u.call({1: 2}, 1) ? function (t) {
                var e = f(this, t);
                return !!e && e.enumerable
            } : u
        }, d = function (t, e) {
            return {enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e}
        }, p = {}.toString, v = function (t) {
            return p.call(t).slice(8, -1)
        }, g = "".split, y = c((function () {
            return !Object("z").propertyIsEnumerable(0)
        })) ? function (t) {
            return "String" == v(t) ? g.call(t, "") : Object(t)
        } : Object, b = function (t) {
            if (null == t) throw TypeError("Can't call method on " + t);
            return t
        }, m = function (t) {
            return y(b(t))
        }, x = function (t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }, E = function (t, e) {
            if (!x(t)) return t;
            var r, n;
            if (e && "function" == typeof (r = t.toString) && !x(n = r.call(t))) return n;
            if ("function" == typeof (r = t.valueOf) && !x(n = r.call(t))) return n;
            if (!e && "function" == typeof (r = t.toString) && !x(n = r.call(t))) return n;
            throw TypeError("Can't convert object to primitive value")
        }, w = {}.hasOwnProperty, O = function (t, e) {
            return w.call(t, e)
        }, _ = a.document, S = x(_) && x(_.createElement), A = function (t) {
            return S ? _.createElement(t) : {}
        }, k = !l && !c((function () {
            return 7 != Object.defineProperty(A("div"), "a", {
                get: function () {
                    return 7
                }
            }).a
        })), L = Object.getOwnPropertyDescriptor, M = {
            f: l ? L : function (t, e) {
                if (t = m(t), e = E(e, !0), k) try {
                    return L(t, e)
                } catch (t) {
                }
                if (O(t, e)) return d(!h.f.call(t, e), t[e])
            }
        }, T = function (t) {
            if (!x(t)) throw TypeError(String(t) + " is not an object");
            return t
        }, j = Object.defineProperty, R = {
            f: l ? j : function (t, e, r) {
                if (T(t), e = E(e, !0), T(r), k) try {
                    return j(t, e, r)
                } catch (t) {
                }
                if ("get" in r || "set" in r) throw TypeError("Accessors not supported");
                return "value" in r && (t[e] = r.value), t
            }
        }, W = l ? function (t, e, r) {
            return R.f(t, e, d(1, r))
        } : function (t, e, r) {
            return t[e] = r, t
        }, z = function (t, e) {
            try {
                W(a, t, e)
            } catch (r) {
                a[t] = e
            }
            return e
        }, C = e((function (t) {
            var e = a["__core-js_shared__"] || z("__core-js_shared__", {});
            (t.exports = function (t, r) {
                return e[t] || (e[t] = void 0 !== r ? r : {})
            })("versions", []).push({version: "3.2.1", mode: "global", copyright: " 2019 Denis Pushkarev (zloirock.ru)"})
        })), N = C("native-function-to-string", Function.toString), I = a.WeakMap,
        D = "function" == typeof I && /native code/.test(N.call(I)), P = 0, V = Math.random(), F = function (t) {
            return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++P + V).toString(36)
        }, B = C("keys"), H = function (t) {
            return B[t] || (B[t] = F(t))
        }, q = {}, $ = a.WeakMap;
    if (D) {
        var X = new $, Y = X.get, G = X.has, U = X.set;
        r = function (t, e) {
            return U.call(X, t, e), e
        }, n = function (t) {
            return Y.call(X, t) || {}
        }, i = function (t) {
            return G.call(X, t)
        }
    } else {
        var Q = H("state");
        q[Q] = !0, r = function (t, e) {
            return W(t, Q, e), e
        }, n = function (t) {
            return O(t, Q) ? t[Q] : {}
        }, i = function (t) {
            return O(t, Q)
        }
    }
    var K = {
            set: r, get: n, has: i, enforce: function (t) {
                return i(t) ? n(t) : r(t, {})
            }, getterFor: function (t) {
                return function (e) {
                    var r;
                    if (!x(e) || (r = n(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
                    return r
                }
            }
        }, J = e((function (t) {
            var e = K.get, r = K.enforce, n = String(N).split("toString");
            C("inspectSource", (function (t) {
                return N.call(t)
            })), (t.exports = function (t, e, i, o) {
                var s = !!o && !!o.unsafe, c = !!o && !!o.enumerable, l = !!o && !!o.noTargetGet;
                "function" == typeof i && ("string" != typeof e || O(i, "name") || W(i, "name", e), r(i).source = n.join("string" == typeof e ? e : "")), t !== a ? (s ? !l && t[e] && (c = !0) : delete t[e], c ? t[e] = i : W(t, e, i)) : c ? t[e] = i : z(e, i)
            })(Function.prototype, "toString", (function () {
                return "function" == typeof this && e(this).source || N.call(this)
            }))
        })), Z = a, tt = function (t) {
            return "function" == typeof t ? t : void 0
        }, et = function (t, e) {
            return arguments.length < 2 ? tt(Z[t]) || tt(a[t]) : Z[t] && Z[t][e] || a[t] && a[t][e]
        }, rt = Math.ceil, nt = Math.floor, it = function (t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? nt : rt)(t)
        }, ot = Math.min, st = function (t) {
            return t > 0 ? ot(it(t), 9007199254740991) : 0
        }, at = Math.max, ct = Math.min, lt = function (t) {
            return function (e, r, n) {
                var i, o = m(e), s = st(o.length), a = function (t, e) {
                    var r = it(t);
                    return r < 0 ? at(r + e, 0) : ct(r, e)
                }(n, s);
                if (t && r != r) {
                    for (; s > a;) if ((i = o[a++]) != i) return !0
                } else for (; s > a; a++) if ((t || a in o) && o[a] === r) return t || a || 0;
                return !t && -1
            }
        }, ut = {includes: lt(!0), indexOf: lt(!1)}.indexOf, ft = function (t, e) {
            var r, n = m(t), i = 0, o = [];
            for (r in n) !O(q, r) && O(n, r) && o.push(r);
            for (; e.length > i;) O(n, r = e[i++]) && (~ut(o, r) || o.push(r));
            return o
        },
        ht = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
        dt = ht.concat("length", "prototype"), pt = {
            f: Object.getOwnPropertyNames || function (t) {
                return ft(t, dt)
            }
        }, vt = {f: Object.getOwnPropertySymbols}, gt = et("Reflect", "ownKeys") || function (t) {
            var e = pt.f(T(t)), r = vt.f;
            return r ? e.concat(r(t)) : e
        }, yt = function (t, e) {
            for (var r = gt(e), n = R.f, i = M.f, o = 0; o < r.length; o++) {
                var s = r[o];
                O(t, s) || n(t, s, i(e, s))
            }
        }, bt = /#|\.prototype\./, mt = function (t, e) {
            var r = Et[xt(t)];
            return r == Ot || r != wt && ("function" == typeof e ? c(e) : !!e)
        }, xt = mt.normalize = function (t) {
            return String(t).replace(bt, ".").toLowerCase()
        }, Et = mt.data = {}, wt = mt.NATIVE = "N", Ot = mt.POLYFILL = "P", _t = mt, St = M.f, At = function (t, e) {
            var r, n, i, o, s, c = t.target, l = t.global, u = t.stat;
            if (r = l ? a : u ? a[c] || z(c, {}) : (a[c] || {}).prototype) for (n in e) {
                if (o = e[n], i = t.noTargetGet ? (s = St(r, n)) && s.value : r[n], !_t(l ? n : c + (u ? "." : "#") + n, t.forced) && void 0 !== i) {
                    if (typeof o == typeof i) continue;
                    yt(o, i)
                }
                (t.sham || i && i.sham) && W(o, "sham", !0), J(r, n, o, t)
            }
        }, kt = function (t) {
            if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
            return t
        }, Lt = function (t, e, r) {
            if (kt(t), void 0 === e) return t;
            switch (r) {
                case 0:
                    return function () {
                        return t.call(e)
                    };
                case 1:
                    return function (r) {
                        return t.call(e, r)
                    };
                case 2:
                    return function (r, n) {
                        return t.call(e, r, n)
                    };
                case 3:
                    return function (r, n, i) {
                        return t.call(e, r, n, i)
                    }
            }
            return function () {
                return t.apply(e, arguments)
            }
        }, Mt = function (t) {
            return Object(b(t))
        }, Tt = Array.isArray || function (t) {
            return "Array" == v(t)
        }, jt = !!Object.getOwnPropertySymbols && !c((function () {
            return !String(Symbol())
        })), Rt = a.Symbol, Wt = C("wks"), zt = function (t) {
            return Wt[t] || (Wt[t] = jt && Rt[t] || (jt ? Rt : F)("Symbol." + t))
        }, Ct = zt("species"), Nt = function (t, e) {
            var r;
            return Tt(t) && ("function" != typeof (r = t.constructor) || r !== Array && !Tt(r.prototype) ? x(r) && null === (r = r[Ct]) && (r = void 0) : r = void 0), new (void 0 === r ? Array : r)(0 === e ? 0 : e)
        }, It = [].push, Dt = function (t) {
            var e = 1 == t, r = 2 == t, n = 3 == t, i = 4 == t, o = 6 == t, s = 5 == t || o;
            return function (a, c, l, u) {
                for (var f, h, d = Mt(a), p = y(d), v = Lt(c, l, 3), g = st(p.length), b = 0, m = u || Nt, x = e ? m(a, g) : r ? m(a, 0) : void 0; g > b; b++) if ((s || b in p) && (h = v(f = p[b], b, d), t)) if (e) x[b] = h; else if (h) switch (t) {
                    case 3:
                        return !0;
                    case 5:
                        return f;
                    case 6:
                        return b;
                    case 2:
                        It.call(x, f)
                } else if (i) return !1;
                return o ? -1 : n || i ? i : x
            }
        }, Pt = {forEach: Dt(0), map: Dt(1), filter: Dt(2), some: Dt(3), every: Dt(4), find: Dt(5), findIndex: Dt(6)},
        Vt = function (t, e) {
            var r = [][t];
            return !r || !c((function () {
                r.call(null, e || function () {
                    throw 1
                }, 1)
            }))
        }, Ft = Pt.forEach, Bt = Vt("forEach") ? function (t) {
            return Ft(this, t, arguments.length > 1 ? arguments[1] : void 0)
        } : [].forEach;
    At({target: "Array", proto: !0, forced: [].forEach != Bt}, {forEach: Bt});
    var Ht = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    };
    for (var qt in Ht) {
        var $t = a[qt], Xt = $t && $t.prototype;
        if (Xt && Xt.forEach !== Bt) try {
            W(Xt, "forEach", Bt)
        } catch (t) {
            Xt.forEach = Bt
        }
    }
    var Yt = !("undefined" == typeof window || !window.document || !window.document.createElement), Gt = zt("species"),
        Ut = Pt.filter;
    At({
        target: "Array", proto: !0, forced: !function (t) {
            return !c((function () {
                var e = [];
                return (e.constructor = {})[Gt] = function () {
                    return {foo: 1}
                }, 1 !== e[t](Boolean).foo
            }))
        }("filter")
    }, {
        filter: function (t) {
            return Ut(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Qt = Object.keys || function (t) {
        return ft(t, ht)
    }, Kt = l ? Object.defineProperties : function (t, e) {
        T(t);
        for (var r, n = Qt(e), i = n.length, o = 0; i > o;) R.f(t, r = n[o++], e[r]);
        return t
    }, Jt = et("document", "documentElement"), Zt = H("IE_PROTO"), te = function () {
    }, ee = function () {
        var t, e = A("iframe"), r = ht.length;
        for (e.style.display = "none", Jt.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), ee = t.F; r--;) delete ee.prototype[ht[r]];
        return ee()
    }, re = Object.create || function (t, e) {
        var r;
        return null !== t ? (te.prototype = T(t), r = new te, te.prototype = null, r[Zt] = t) : r = ee(), void 0 === e ? r : Kt(r, e)
    };
    q[Zt] = !0;
    var ne = zt("unscopables"), ie = Array.prototype;
    null == ie[ne] && W(ie, ne, re(null));
    var oe, se, ae, ce = function (t) {
        ie[ne][t] = !0
    }, le = {}, ue = !c((function () {
        function t() {
        }

        return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
    })), fe = H("IE_PROTO"), he = Object.prototype, de = ue ? Object.getPrototypeOf : function (t) {
        return t = Mt(t), O(t, fe) ? t[fe] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? he : null
    }, pe = zt("iterator"), ve = !1;
    [].keys && ("next" in (ae = [].keys()) ? (se = de(de(ae))) !== Object.prototype && (oe = se) : ve = !0), null == oe && (oe = {}), O(oe, pe) || W(oe, pe, (function () {
        return this
    }));
    var ge = {IteratorPrototype: oe, BUGGY_SAFARI_ITERATORS: ve}, ye = R.f, be = zt("toStringTag"),
        me = function (t, e, r) {
            t && !O(t = r ? t : t.prototype, be) && ye(t, be, {configurable: !0, value: e})
        }, xe = ge.IteratorPrototype, Ee = function () {
            return this
        }, we = Object.setPrototypeOf || ("__proto__" in {} ? function () {
            var t, e = !1, r = {};
            try {
                (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r, []), e = r instanceof Array
            } catch (t) {
            }
            return function (r, n) {
                return T(r), function (t) {
                    if (!x(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype")
                }(n), e ? t.call(r, n) : r.__proto__ = n, r
            }
        }() : void 0), Oe = ge.IteratorPrototype, _e = ge.BUGGY_SAFARI_ITERATORS, Se = zt("iterator"), Ae = function () {
            return this
        }, ke = function (t, e, r, n, i, o, s) {
            !function (t, e, r) {
                var n = e + " Iterator";
                t.prototype = re(xe, {next: d(1, r)}), me(t, n, !1), le[n] = Ee
            }(r, e, n);
            var a, c, l, u = function (t) {
                    if (t === i && g) return g;
                    if (!_e && t in p) return p[t];
                    switch (t) {
                        case"keys":
                        case"values":
                        case"entries":
                            return function () {
                                return new r(this, t)
                            }
                    }
                    return function () {
                        return new r(this)
                    }
                }, f = e + " Iterator", h = !1, p = t.prototype, v = p[Se] || p["@@iterator"] || i && p[i],
                g = !_e && v || u(i), y = "Array" == e && p.entries || v;
            if (y && (a = de(y.call(new t)), Oe !== Object.prototype && a.next && (de(a) !== Oe && (we ? we(a, Oe) : "function" != typeof a[Se] && W(a, Se, Ae)), me(a, f, !0))), "values" == i && v && "values" !== v.name && (h = !0, g = function () {
                return v.call(this)
            }), p[Se] !== g && W(p, Se, g), le[e] = g, i) if (c = {
                values: u("values"),
                keys: o ? g : u("keys"),
                entries: u("entries")
            }, s) for (l in c) !_e && !h && l in p || J(p, l, c[l]); else At({target: e, proto: !0, forced: _e || h}, c);
            return c
        }, Le = K.set, Me = K.getterFor("Array Iterator"), Te = ke(Array, "Array", (function (t, e) {
            Le(this, {type: "Array Iterator", target: m(t), index: 0, kind: e})
        }), (function () {
            var t = Me(this), e = t.target, r = t.kind, n = t.index++;
            return !e || n >= e.length ? (t.target = void 0, {value: void 0, done: !0}) : "keys" == r ? {
                value: n,
                done: !1
            } : "values" == r ? {value: e[n], done: !1} : {value: [n, e[n]], done: !1}
        }), "values");
    le.Arguments = le.Array, ce("keys"), ce("values"), ce("entries");
    var je = Object.assign, Re = !je || c((function () {
        var t = {}, e = {}, r = Symbol();
        return t[r] = 7, "abcdefghijklmnopqrst".split("").forEach((function (t) {
            e[t] = t
        })), 7 != je({}, t)[r] || "abcdefghijklmnopqrst" != Qt(je({}, e)).join("")
    })) ? function (t, e) {
        for (var r = Mt(t), n = arguments.length, i = 1, o = vt.f, s = h.f; n > i;) for (var a, c = y(arguments[i++]), u = o ? Qt(c).concat(o(c)) : Qt(c), f = u.length, d = 0; f > d;) a = u[d++], l && !s.call(c, a) || (r[a] = c[a]);
        return r
    } : je;
    At({target: "Object", stat: !0, forced: Object.assign !== Re}, {assign: Re});
    var We = zt("toStringTag"), ze = "Arguments" == v(function () {
        return arguments
    }()), Ce = function (t) {
        var e, r, n;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function (t, e) {
            try {
                return t[e]
            } catch (t) {
            }
        }(e = Object(t), We)) ? r : ze ? v(e) : "Object" == (n = v(e)) && "function" == typeof e.callee ? "Arguments" : n
    }, Ne = {};
    Ne[zt("toStringTag")] = "z";
    var Ie = "[object z]" !== String(Ne) ? function () {
        return "[object " + Ce(this) + "]"
    } : Ne.toString, De = Object.prototype;
    Ie !== De.toString && J(De, "toString", Ie, {unsafe: !0});
    var Pe = "\t\n\v\f\r \u2028\u2029\ufeff", Ve = "[" + Pe + "]", Fe = RegExp("^" + Ve + Ve + "*"),
        Be = RegExp(Ve + Ve + "*$"), He = function (t) {
            return function (e) {
                var r = String(b(e));
                return 1 & t && (r = r.replace(Fe, "")), 2 & t && (r = r.replace(Be, "")), r
            }
        }, qe = {start: He(1), end: He(2), trim: He(3)}.trim, $e = a.parseInt, Xe = /^[+-]?0[Xx]/,
        Ye = 8 !== $e(Pe + "08") || 22 !== $e(Pe + "0x16") ? function (t, e) {
            var r = qe(String(t));
            return $e(r, e >>> 0 || (Xe.test(r) ? 16 : 10))
        } : $e;
    At({global: !0, forced: parseInt != Ye}, {parseInt: Ye});
    var Ge = function (t) {
        return function (e, r) {
            var n, i, o = String(b(e)), s = it(r), a = o.length;
            return s < 0 || s >= a ? t ? "" : void 0 : (n = o.charCodeAt(s)) < 55296 || n > 56319 || s + 1 === a || (i = o.charCodeAt(s + 1)) < 56320 || i > 57343 ? t ? o.charAt(s) : n : t ? o.slice(s, s + 2) : i - 56320 + (n - 55296 << 10) + 65536
        }
    }, Ue = {codeAt: Ge(!1), charAt: Ge(!0)}, Qe = Ue.charAt, Ke = K.set, Je = K.getterFor("String Iterator");
    ke(String, "String", (function (t) {
        Ke(this, {type: "String Iterator", string: String(t), index: 0})
    }), (function () {
        var t, e = Je(this), r = e.string, n = e.index;
        return n >= r.length ? {value: void 0, done: !0} : (t = Qe(r, n), e.index += t.length, {value: t, done: !1})
    }));
    var Ze = function (t, e, r) {
            for (var n in e) J(t, n, e[n], r);
            return t
        }, tr = !c((function () {
            return Object.isExtensible(Object.preventExtensions({}))
        })), er = e((function (t) {
            var e = R.f, r = F("meta"), n = 0, i = Object.isExtensible || function () {
                return !0
            }, o = function (t) {
                e(t, r, {value: {objectID: "O" + ++n, weakData: {}}})
            }, s = t.exports = {
                REQUIRED: !1, fastKey: function (t, e) {
                    if (!x(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!O(t, r)) {
                        if (!i(t)) return "F";
                        if (!e) return "E";
                        o(t)
                    }
                    return t[r].objectID
                }, getWeakData: function (t, e) {
                    if (!O(t, r)) {
                        if (!i(t)) return !0;
                        if (!e) return !1;
                        o(t)
                    }
                    return t[r].weakData
                }, onFreeze: function (t) {
                    return tr && s.REQUIRED && i(t) && !O(t, r) && o(t), t
                }
            };
            q[r] = !0
        })), rr = (er.REQUIRED, er.fastKey, er.getWeakData, er.onFreeze, zt("iterator")), nr = Array.prototype,
        ir = zt("iterator"), or = function (t, e, r, n) {
            try {
                return n ? e(T(r)[0], r[1]) : e(r)
            } catch (e) {
                var i = t.return;
                throw void 0 !== i && T(i.call(t)), e
            }
        }, sr = e((function (t) {
            var e = function (t, e) {
                this.stopped = t, this.result = e
            };
            (t.exports = function (t, r, n, i, o) {
                var s, a, c, l, u, f, h, d = Lt(r, n, i ? 2 : 1);
                if (o) s = t; else {
                    if ("function" != typeof (a = function (t) {
                        if (null != t) return t[ir] || t["@@iterator"] || le[Ce(t)]
                    }(t))) throw TypeError("Target is not iterable");
                    if (void 0 !== (h = a) && (le.Array === h || nr[rr] === h)) {
                        for (c = 0, l = st(t.length); l > c; c++) if ((u = i ? d(T(f = t[c])[0], f[1]) : d(t[c])) && u instanceof e) return u;
                        return new e(!1)
                    }
                    s = a.call(t)
                }
                for (; !(f = s.next()).done;) if ((u = or(s, d, f.value, i)) && u instanceof e) return u;
                return new e(!1)
            }).stop = function (t) {
                return new e(!0, t)
            }
        })), ar = function (t, e, r) {
            if (!(t instanceof e)) throw TypeError("Incorrect " + (r ? r + " " : "") + "invocation");
            return t
        }, cr = zt("iterator"), lr = !1;
    try {
        var ur = 0, fr = {
            next: function () {
                return {done: !!ur++}
            }, return: function () {
                lr = !0
            }
        };
        fr[cr] = function () {
            return this
        }, Array.from(fr, (function () {
            throw 2
        }))
    } catch (t) {
    }
    var hr = function (t, e, r, n, i) {
        var o = a[t], s = o && o.prototype, l = o, u = n ? "set" : "add", f = {}, h = function (t) {
            var e = s[t];
            J(s, t, "add" == t ? function (t) {
                return e.call(this, 0 === t ? 0 : t), this
            } : "delete" == t ? function (t) {
                return !(i && !x(t)) && e.call(this, 0 === t ? 0 : t)
            } : "get" == t ? function (t) {
                return i && !x(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
            } : "has" == t ? function (t) {
                return !(i && !x(t)) && e.call(this, 0 === t ? 0 : t)
            } : function (t, r) {
                return e.call(this, 0 === t ? 0 : t, r), this
            })
        };
        if (_t(t, "function" != typeof o || !(i || s.forEach && !c((function () {
            (new o).entries().next()
        }))))) l = r.getConstructor(e, t, n, u), er.REQUIRED = !0; else if (_t(t, !0)) {
            var d = new l, p = d[u](i ? {} : -0, 1) != d, v = c((function () {
                d.has(1)
            })), g = function (t, e) {
                if (!e && !lr) return !1;
                var r = !1;
                try {
                    var n = {};
                    n[cr] = function () {
                        return {
                            next: function () {
                                return {done: r = !0}
                            }
                        }
                    }, t(n)
                } catch (t) {
                }
                return r
            }((function (t) {
                new o(t)
            })), y = !i && c((function () {
                for (var t = new o, e = 5; e--;) t[u](e, e);
                return !t.has(-0)
            }));
            g || ((l = e((function (e, r) {
                ar(e, l, t);
                var i = function (t, e, r) {
                    var n, i;
                    return we && "function" == typeof (n = e.constructor) && n !== r && x(i = n.prototype) && i !== r.prototype && we(t, i), t
                }(new o, e, l);
                return null != r && sr(r, i[u], i, n), i
            }))).prototype = s, s.constructor = l), (v || y) && (h("delete"), h("has"), n && h("get")), (y || p) && h(u), i && s.clear && delete s.clear
        }
        return f[t] = l, At({global: !0, forced: l != o}, f), me(l, t), i || r.setStrong(l, t, n), l
    }, dr = er.getWeakData, pr = K.set, vr = K.getterFor, gr = Pt.find, yr = Pt.findIndex, br = 0, mr = function (t) {
        return t.frozen || (t.frozen = new xr)
    }, xr = function () {
        this.entries = []
    }, Er = function (t, e) {
        return gr(t.entries, (function (t) {
            return t[0] === e
        }))
    };
    xr.prototype = {
        get: function (t) {
            var e = Er(this, t);
            if (e) return e[1]
        }, has: function (t) {
            return !!Er(this, t)
        }, set: function (t, e) {
            var r = Er(this, t);
            r ? r[1] = e : this.entries.push([t, e])
        }, delete: function (t) {
            var e = yr(this.entries, (function (e) {
                return e[0] === t
            }));
            return ~e && this.entries.splice(e, 1), !!~e
        }
    };
    var wr = {
        getConstructor: function (t, e, r, n) {
            var i = t((function (t, o) {
                ar(t, i, e), pr(t, {type: e, id: br++, frozen: void 0}), null != o && sr(o, t[n], t, r)
            })), o = vr(e), s = function (t, e, r) {
                var n = o(t), i = dr(T(e), !0);
                return !0 === i ? mr(n).set(e, r) : i[n.id] = r, t
            };
            return Ze(i.prototype, {
                delete: function (t) {
                    var e = o(this);
                    if (!x(t)) return !1;
                    var r = dr(t);
                    return !0 === r ? mr(e).delete(t) : r && O(r, e.id) && delete r[e.id]
                }, has: function (t) {
                    var e = o(this);
                    if (!x(t)) return !1;
                    var r = dr(t);
                    return !0 === r ? mr(e).has(t) : r && O(r, e.id)
                }
            }), Ze(i.prototype, r ? {
                get: function (t) {
                    var e = o(this);
                    if (x(t)) {
                        var r = dr(t);
                        return !0 === r ? mr(e).get(t) : r ? r[e.id] : void 0
                    }
                }, set: function (t, e) {
                    return s(this, t, e)
                }
            } : {
                add: function (t) {
                    return s(this, t, !0)
                }
            }), i
        }
    }, Or = (e((function (t) {
        var e, r = K.enforce, n = !a.ActiveXObject && "ActiveXObject" in a, i = Object.isExtensible, o = function (t) {
            return function () {
                return t(this, arguments.length ? arguments[0] : void 0)
            }
        }, s = t.exports = hr("WeakMap", o, wr, !0, !0);
        if (D && n) {
            e = wr.getConstructor(o, "WeakMap", !0), er.REQUIRED = !0;
            var c = s.prototype, l = c.delete, u = c.has, f = c.get, h = c.set;
            Ze(c, {
                delete: function (t) {
                    if (x(t) && !i(t)) {
                        var n = r(this);
                        return n.frozen || (n.frozen = new e), l.call(this, t) || n.frozen.delete(t)
                    }
                    return l.call(this, t)
                }, has: function (t) {
                    if (x(t) && !i(t)) {
                        var n = r(this);
                        return n.frozen || (n.frozen = new e), u.call(this, t) || n.frozen.has(t)
                    }
                    return u.call(this, t)
                }, get: function (t) {
                    if (x(t) && !i(t)) {
                        var n = r(this);
                        return n.frozen || (n.frozen = new e), u.call(this, t) ? f.call(this, t) : n.frozen.get(t)
                    }
                    return f.call(this, t)
                }, set: function (t, n) {
                    if (x(t) && !i(t)) {
                        var o = r(this);
                        o.frozen || (o.frozen = new e), u.call(this, t) ? h.call(this, t, n) : o.frozen.set(t, n)
                    } else h.call(this, t, n);
                    return this
                }
            })
        }
    })), zt("iterator")), _r = zt("toStringTag"), Sr = Te.values;
    for (var Ar in Ht) {
        var kr = a[Ar], Lr = kr && kr.prototype;
        if (Lr) {
            if (Lr[Or] !== Sr) try {
                W(Lr, Or, Sr)
            } catch (t) {
                Lr[Or] = Sr
            }
            if (Lr[_r] || W(Lr, _r, Ar), Ht[Ar]) for (var Mr in Te) if (Lr[Mr] !== Te[Mr]) try {
                W(Lr, Mr, Te[Mr])
            } catch (t) {
                Lr[Mr] = Te[Mr]
            }
        }
    }
    var Tr = "Expected a function", jr = NaN, Rr = "[object Symbol]", Wr = /^\s+|\s+$/g, zr = /^[-+]0x[0-9a-f]+$/i,
        Cr = /^0b[01]+$/i, Nr = /^0o[0-7]+$/i, Ir = parseInt,
        Dr = "object" == typeof t && t && t.Object === Object && t,
        Pr = "object" == typeof self && self && self.Object === Object && self,
        Vr = Dr || Pr || Function("return this")(), Fr = Object.prototype.toString, Br = Math.max, Hr = Math.min,
        qr = function () {
            return Vr.Date.now()
        };

    function $r(t, e, r) {
        var n, i, o, s, a, c, l = 0, u = !1, f = !1, h = !0;
        if ("function" != typeof t) throw new TypeError(Tr);

        function d(e) {
            var r = n, o = i;
            return n = i = void 0, l = e, s = t.apply(o, r)
        }

        function p(t) {
            var r = t - c;
            return void 0 === c || r >= e || r < 0 || f && t - l >= o
        }

        function v() {
            var t = qr();
            if (p(t)) return g(t);
            a = setTimeout(v, function (t) {
                var r = e - (t - c);
                return f ? Hr(r, o - (t - l)) : r
            }(t))
        }

        function g(t) {
            return a = void 0, h && n ? d(t) : (n = i = void 0, s)
        }

        function y() {
            var t = qr(), r = p(t);
            if (n = arguments, i = this, c = t, r) {
                if (void 0 === a) return function (t) {
                    return l = t, a = setTimeout(v, e), u ? d(t) : s
                }(c);
                if (f) return a = setTimeout(v, e), d(c)
            }
            return void 0 === a && (a = setTimeout(v, e)), s
        }

        return e = Yr(e) || 0, Xr(r) && (u = !!r.leading, o = (f = "maxWait" in r) ? Br(Yr(r.maxWait) || 0, e) : o, h = "trailing" in r ? !!r.trailing : h), y.cancel = function () {
            void 0 !== a && clearTimeout(a), l = 0, n = c = i = a = void 0
        }, y.flush = function () {
            return void 0 === a ? s : g(qr())
        }, y
    }

    function Xr(t) {
        var e = typeof t;
        return !!t && ("object" == e || "function" == e)
    }

    function Yr(t) {
        if ("number" == typeof t) return t;
        if (function (t) {
            return "symbol" == typeof t || function (t) {
                return !!t && "object" == typeof t
            }(t) && Fr.call(t) == Rr
        }(t)) return jr;
        if (Xr(t)) {
            var e = "function" == typeof t.valueOf ? t.valueOf() : t;
            t = Xr(e) ? e + "" : e
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = t.replace(Wr, "");
        var r = Cr.test(t);
        return r || Nr.test(t) ? Ir(t.slice(2), r ? 2 : 8) : zr.test(t) ? jr : +t
    }

    var Gr = function (t, e, r) {
            var n = !0, i = !0;
            if ("function" != typeof t) throw new TypeError(Tr);
            return Xr(r) && (n = "leading" in r ? !!r.leading : n, i = "trailing" in r ? !!r.trailing : i), $r(t, e, {
                leading: n,
                maxWait: e,
                trailing: i
            })
        }, Ur = "Expected a function", Qr = NaN, Kr = "[object Symbol]", Jr = /^\s+|\s+$/g, Zr = /^[-+]0x[0-9a-f]+$/i,
        tn = /^0b[01]+$/i, en = /^0o[0-7]+$/i, rn = parseInt,
        nn = "object" == typeof t && t && t.Object === Object && t,
        on = "object" == typeof self && self && self.Object === Object && self,
        sn = nn || on || Function("return this")(), an = Object.prototype.toString, cn = Math.max, ln = Math.min,
        un = function () {
            return sn.Date.now()
        };

    function fn(t) {
        var e = typeof t;
        return !!t && ("object" == e || "function" == e)
    }

    function hn(t) {
        if ("number" == typeof t) return t;
        if (function (t) {
            return "symbol" == typeof t || function (t) {
                return !!t && "object" == typeof t
            }(t) && an.call(t) == Kr
        }(t)) return Qr;
        if (fn(t)) {
            var e = "function" == typeof t.valueOf ? t.valueOf() : t;
            t = fn(e) ? e + "" : e
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = t.replace(Jr, "");
        var r = tn.test(t);
        return r || en.test(t) ? rn(t.slice(2), r ? 2 : 8) : Zr.test(t) ? Qr : +t
    }

    var dn = function (t, e, r) {
            var n, i, o, s, a, c, l = 0, u = !1, f = !1, h = !0;
            if ("function" != typeof t) throw new TypeError(Ur);

            function d(e) {
                var r = n, o = i;
                return n = i = void 0, l = e, s = t.apply(o, r)
            }

            function p(t) {
                var r = t - c;
                return void 0 === c || r >= e || r < 0 || f && t - l >= o
            }

            function v() {
                var t = un();
                if (p(t)) return g(t);
                a = setTimeout(v, function (t) {
                    var r = e - (t - c);
                    return f ? ln(r, o - (t - l)) : r
                }(t))
            }

            function g(t) {
                return a = void 0, h && n ? d(t) : (n = i = void 0, s)
            }

            function y() {
                var t = un(), r = p(t);
                if (n = arguments, i = this, c = t, r) {
                    if (void 0 === a) return function (t) {
                        return l = t, a = setTimeout(v, e), u ? d(t) : s
                    }(c);
                    if (f) return a = setTimeout(v, e), d(c)
                }
                return void 0 === a && (a = setTimeout(v, e)), s
            }

            return e = hn(e) || 0, fn(r) && (u = !!r.leading, o = (f = "maxWait" in r) ? cn(hn(r.maxWait) || 0, e) : o, h = "trailing" in r ? !!r.trailing : h), y.cancel = function () {
                void 0 !== a && clearTimeout(a), l = 0, n = c = i = a = void 0
            }, y.flush = function () {
                return void 0 === a ? s : g(un())
            }, y
        }, pn = "Expected a function", vn = "__lodash_hash_undefined__", gn = "[object Function]",
        yn = "[object GeneratorFunction]", bn = /^\[object .+?Constructor\]$/,
        mn = "object" == typeof t && t && t.Object === Object && t,
        xn = "object" == typeof self && self && self.Object === Object && self,
        En = mn || xn || Function("return this")();
    var wn = Array.prototype, On = Function.prototype, _n = Object.prototype, Sn = En["__core-js_shared__"],
        An = function () {
            var t = /[^.]+$/.exec(Sn && Sn.keys && Sn.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }(), kn = On.toString, Ln = _n.hasOwnProperty, Mn = _n.toString,
        Tn = RegExp("^" + kn.call(Ln).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        jn = wn.splice, Rn = Vn(En, "Map"), Wn = Vn(Object, "create");

    function zn(t) {
        var e = -1, r = t ? t.length : 0;
        for (this.clear(); ++e < r;) {
            var n = t[e];
            this.set(n[0], n[1])
        }
    }

    function Cn(t) {
        var e = -1, r = t ? t.length : 0;
        for (this.clear(); ++e < r;) {
            var n = t[e];
            this.set(n[0], n[1])
        }
    }

    function Nn(t) {
        var e = -1, r = t ? t.length : 0;
        for (this.clear(); ++e < r;) {
            var n = t[e];
            this.set(n[0], n[1])
        }
    }

    function In(t, e) {
        for (var r, n, i = t.length; i--;) if ((r = t[i][0]) === (n = e) || r != r && n != n) return i;
        return -1
    }

    function Dn(t) {
        return !(!Bn(t) || (e = t, An && An in e)) && (function (t) {
            var e = Bn(t) ? Mn.call(t) : "";
            return e == gn || e == yn
        }(t) || function (t) {
            var e = !1;
            if (null != t && "function" != typeof t.toString) try {
                e = !!(t + "")
            } catch (t) {
            }
            return e
        }(t) ? Tn : bn).test(function (t) {
            if (null != t) {
                try {
                    return kn.call(t)
                } catch (t) {
                }
                try {
                    return t + ""
                } catch (t) {
                }
            }
            return ""
        }(t));
        var e
    }

    function Pn(t, e) {
        var r, n, i = t.__data__;
        return ("string" == (n = typeof (r = e)) || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== r : null === r) ? i["string" == typeof e ? "string" : "hash"] : i.map
    }

    function Vn(t, e) {
        var r = function (t, e) {
            return null == t ? void 0 : t[e]
        }(t, e);
        return Dn(r) ? r : void 0
    }

    function Fn(t, e) {
        if ("function" != typeof t || e && "function" != typeof e) throw new TypeError(pn);
        var r = function () {
            var n = arguments, i = e ? e.apply(this, n) : n[0], o = r.cache;
            if (o.has(i)) return o.get(i);
            var s = t.apply(this, n);
            return r.cache = o.set(i, s), s
        };
        return r.cache = new (Fn.Cache || Nn), r
    }

    function Bn(t) {
        var e = typeof t;
        return !!t && ("object" == e || "function" == e)
    }

    zn.prototype.clear = function () {
        this.__data__ = Wn ? Wn(null) : {}
    }, zn.prototype.delete = function (t) {
        return this.has(t) && delete this.__data__[t]
    }, zn.prototype.get = function (t) {
        var e = this.__data__;
        if (Wn) {
            var r = e[t];
            return r === vn ? void 0 : r
        }
        return Ln.call(e, t) ? e[t] : void 0
    }, zn.prototype.has = function (t) {
        var e = this.__data__;
        return Wn ? void 0 !== e[t] : Ln.call(e, t)
    }, zn.prototype.set = function (t, e) {
        return this.__data__[t] = Wn && void 0 === e ? vn : e, this
    }, Cn.prototype.clear = function () {
        this.__data__ = []
    }, Cn.prototype.delete = function (t) {
        var e = this.__data__, r = In(e, t);
        return !(r < 0) && (r == e.length - 1 ? e.pop() : jn.call(e, r, 1), !0)
    }, Cn.prototype.get = function (t) {
        var e = this.__data__, r = In(e, t);
        return r < 0 ? void 0 : e[r][1]
    }, Cn.prototype.has = function (t) {
        return In(this.__data__, t) > -1
    }, Cn.prototype.set = function (t, e) {
        var r = this.__data__, n = In(r, t);
        return n < 0 ? r.push([t, e]) : r[n][1] = e, this
    }, Nn.prototype.clear = function () {
        this.__data__ = {hash: new zn, map: new (Rn || Cn), string: new zn}
    }, Nn.prototype.delete = function (t) {
        return Pn(this, t).delete(t)
    }, Nn.prototype.get = function (t) {
        return Pn(this, t).get(t)
    }, Nn.prototype.has = function (t) {
        return Pn(this, t).has(t)
    }, Nn.prototype.set = function (t, e) {
        return Pn(this, t).set(t, e), this
    }, Fn.Cache = Nn;
    var Hn = Fn, qn = function () {
            if ("undefined" != typeof Map) return Map;

            function t(t, e) {
                var r = -1;
                return t.some((function (t, n) {
                    return t[0] === e && (r = n, !0)
                })), r
            }

            return function () {
                function e() {
                    this.__entries__ = []
                }

                return Object.defineProperty(e.prototype, "size", {
                    get: function () {
                        return this.__entries__.length
                    }, enumerable: !0, configurable: !0
                }), e.prototype.get = function (e) {
                    var r = t(this.__entries__, e), n = this.__entries__[r];
                    return n && n[1]
                }, e.prototype.set = function (e, r) {
                    var n = t(this.__entries__, e);
                    ~n ? this.__entries__[n][1] = r : this.__entries__.push([e, r])
                }, e.prototype.delete = function (e) {
                    var r = this.__entries__, n = t(r, e);
                    ~n && r.splice(n, 1)
                }, e.prototype.has = function (e) {
                    return !!~t(this.__entries__, e)
                }, e.prototype.clear = function () {
                    this.__entries__.splice(0)
                }, e.prototype.forEach = function (t, e) {
                    void 0 === e && (e = null);
                    for (var r = 0, n = this.__entries__; r < n.length; r++) {
                        var i = n[r];
                        t.call(e, i[1], i[0])
                    }
                }, e
            }()
        }(), $n = "undefined" != typeof window && "undefined" != typeof document && window.document === document,
        Xn = "undefined" != typeof global && global.Math === Math ? global : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(),
        Yn = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(Xn) : function (t) {
            return setTimeout((function () {
                return t(Date.now())
            }), 1e3 / 60)
        }, Gn = 2;
    var Un = 20, Qn = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
        Kn = "undefined" != typeof MutationObserver, Jn = function () {
            function t() {
                this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = function (t, e) {
                    var r = !1, n = !1, i = 0;

                    function o() {
                        r && (r = !1, t()), n && a()
                    }

                    function s() {
                        Yn(o)
                    }

                    function a() {
                        var t = Date.now();
                        if (r) {
                            if (t - i < Gn) return;
                            n = !0
                        } else r = !0, n = !1, setTimeout(s, e);
                        i = t
                    }

                    return a
                }(this.refresh.bind(this), Un)
            }

            return t.prototype.addObserver = function (t) {
                ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_()
            }, t.prototype.removeObserver = function (t) {
                var e = this.observers_, r = e.indexOf(t);
                ~r && e.splice(r, 1), !e.length && this.connected_ && this.disconnect_()
            }, t.prototype.refresh = function () {
                this.updateObservers_() && this.refresh()
            }, t.prototype.updateObservers_ = function () {
                var t = this.observers_.filter((function (t) {
                    return t.gatherActive(), t.hasActive()
                }));
                return t.forEach((function (t) {
                    return t.broadcastActive()
                })), t.length > 0
            }, t.prototype.connect_ = function () {
                $n && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), Kn ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0)
            }, t.prototype.disconnect_ = function () {
                $n && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1)
            }, t.prototype.onTransitionEnd_ = function (t) {
                var e = t.propertyName, r = void 0 === e ? "" : e;
                Qn.some((function (t) {
                    return !!~r.indexOf(t)
                })) && this.refresh()
            }, t.getInstance = function () {
                return this.instance_ || (this.instance_ = new t), this.instance_
            }, t.instance_ = null, t
        }(), Zn = function (t, e) {
            for (var r = 0, n = Object.keys(e); r < n.length; r++) {
                var i = n[r];
                Object.defineProperty(t, i, {value: e[i], enumerable: !1, writable: !1, configurable: !0})
            }
            return t
        }, ti = function (t) {
            return t && t.ownerDocument && t.ownerDocument.defaultView || Xn
        }, ei = ai(0, 0, 0, 0);

    function ri(t) {
        return parseFloat(t) || 0
    }

    function ni(t) {
        for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
        return e.reduce((function (e, r) {
            return e + ri(t["border-" + r + "-width"])
        }), 0)
    }

    function ii(t) {
        var e = t.clientWidth, r = t.clientHeight;
        if (!e && !r) return ei;
        var n = ti(t).getComputedStyle(t), i = function (t) {
            for (var e = {}, r = 0, n = ["top", "right", "bottom", "left"]; r < n.length; r++) {
                var i = n[r], o = t["padding-" + i];
                e[i] = ri(o)
            }
            return e
        }(n), o = i.left + i.right, s = i.top + i.bottom, a = ri(n.width), c = ri(n.height);
        if ("border-box" === n.boxSizing && (Math.round(a + o) !== e && (a -= ni(n, "left", "right") + o), Math.round(c + s) !== r && (c -= ni(n, "top", "bottom") + s)), !function (t) {
            return t === ti(t).document.documentElement
        }(t)) {
            var l = Math.round(a + o) - e, u = Math.round(c + s) - r;
            1 !== Math.abs(l) && (a -= l), 1 !== Math.abs(u) && (c -= u)
        }
        return ai(i.left, i.top, a, c)
    }

    var oi = "undefined" != typeof SVGGraphicsElement ? function (t) {
        return t instanceof ti(t).SVGGraphicsElement
    } : function (t) {
        return t instanceof ti(t).SVGElement && "function" == typeof t.getBBox
    };

    function si(t) {
        return $n ? oi(t) ? function (t) {
            var e = t.getBBox();
            return ai(0, 0, e.width, e.height)
        }(t) : ii(t) : ei
    }

    function ai(t, e, r, n) {
        return {x: t, y: e, width: r, height: n}
    }

    var ci = function () {
        function t(t) {
            this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = ai(0, 0, 0, 0), this.target = t
        }

        return t.prototype.isActive = function () {
            var t = si(this.target);
            return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
        }, t.prototype.broadcastRect = function () {
            var t = this.contentRect_;
            return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t
        }, t
    }(), li = function (t, e) {
        var r, n, i, o, s, a, c,
            l = (n = (r = e).x, i = r.y, o = r.width, s = r.height, a = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, c = Object.create(a.prototype), Zn(c, {
                x: n,
                y: i,
                width: o,
                height: s,
                top: i,
                right: n + o,
                bottom: s + i,
                left: n
            }), c);
        Zn(this, {target: t, contentRect: l})
    }, ui = function () {
        function t(t, e, r) {
            if (this.activeObservations_ = [], this.observations_ = new qn, "function" != typeof t) throw new TypeError("The callback provided as parameter 1 is not a function.");
            this.callback_ = t, this.controller_ = e, this.callbackCtx_ = r
        }

        return t.prototype.observe = function (t) {
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            if ("undefined" != typeof Element && Element instanceof Object) {
                if (!(t instanceof ti(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                var e = this.observations_;
                e.has(t) || (e.set(t, new ci(t)), this.controller_.addObserver(this), this.controller_.refresh())
            }
        }, t.prototype.unobserve = function (t) {
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            if ("undefined" != typeof Element && Element instanceof Object) {
                if (!(t instanceof ti(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                var e = this.observations_;
                e.has(t) && (e.delete(t), e.size || this.controller_.removeObserver(this))
            }
        }, t.prototype.disconnect = function () {
            this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
        }, t.prototype.gatherActive = function () {
            var t = this;
            this.clearActive(), this.observations_.forEach((function (e) {
                e.isActive() && t.activeObservations_.push(e)
            }))
        }, t.prototype.broadcastActive = function () {
            if (this.hasActive()) {
                var t = this.callbackCtx_, e = this.activeObservations_.map((function (t) {
                    return new li(t.target, t.broadcastRect())
                }));
                this.callback_.call(t, e, t), this.clearActive()
            }
        }, t.prototype.clearActive = function () {
            this.activeObservations_.splice(0)
        }, t.prototype.hasActive = function () {
            return this.activeObservations_.length > 0
        }, t
    }(), fi = "undefined" != typeof WeakMap ? new WeakMap : new qn, hi = function t(e) {
        if (!(this instanceof t)) throw new TypeError("Cannot call a class as a function.");
        if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
        var r = Jn.getInstance(), n = new ui(e, r, this);
        fi.set(this, n)
    };
    ["observe", "unobserve", "disconnect"].forEach((function (t) {
        hi.prototype[t] = function () {
            var e;
            return (e = fi.get(this))[t].apply(e, arguments)
        }
    }));
    var di = void 0 !== Xn.ResizeObserver ? Xn.ResizeObserver : hi, pi = null, vi = null;

    function gi() {
        if (null === pi) {
            if ("undefined" == typeof document) return pi = 0;
            var t = document.body, e = document.createElement("div");
            e.classList.add("simplebar-hide-scrollbar"), t.appendChild(e);
            var r = e.getBoundingClientRect().right;
            t.removeChild(e), pi = r
        }
        return pi
    }

    Yt && window.addEventListener("resize", (function () {
        vi !== window.devicePixelRatio && (vi = window.devicePixelRatio, pi = null)
    }));
    var yi = function (t) {
        return function (e, r, n, i) {
            kt(r);
            var o = Mt(e), s = y(o), a = st(o.length), c = t ? a - 1 : 0, l = t ? -1 : 1;
            if (n < 2) for (; ;) {
                if (c in s) {
                    i = s[c], c += l;
                    break
                }
                if (c += l, t ? c < 0 : a <= c) throw TypeError("Reduce of empty array with no initial value")
            }
            for (; t ? c >= 0 : a > c; c += l) c in s && (i = r(i, s[c], c, o));
            return i
        }
    }, bi = {left: yi(!1), right: yi(!0)}.left;
    At({target: "Array", proto: !0, forced: Vt("reduce")}, {
        reduce: function (t) {
            return bi(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var mi = R.f, xi = Function.prototype, Ei = xi.toString, wi = /^\s*function ([^ (]*)/;
    !l || "name" in xi || mi(xi, "name", {
        configurable: !0, get: function () {
            try {
                return Ei.call(this).match(wi)[1]
            } catch (t) {
                return ""
            }
        }
    });
    var Oi, _i, Si = function () {
            var t = T(this), e = "";
            return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
        }, Ai = RegExp.prototype.exec, ki = String.prototype.replace, Li = Ai,
        Mi = (Oi = /a/, _i = /b*/g, Ai.call(Oi, "a"), Ai.call(_i, "a"), 0 !== Oi.lastIndex || 0 !== _i.lastIndex),
        Ti = void 0 !== /()??/.exec("")[1];
    (Mi || Ti) && (Li = function (t) {
        var e, r, n, i, o = this;
        return Ti && (r = new RegExp("^" + o.source + "$(?!\\s)", Si.call(o))), Mi && (e = o.lastIndex), n = Ai.call(o, t), Mi && n && (o.lastIndex = o.global ? n.index + n[0].length : e), Ti && n && n.length > 1 && ki.call(n[0], r, (function () {
            for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (n[i] = void 0)
        })), n
    });
    var ji = Li;
    At({target: "RegExp", proto: !0, forced: /./.exec !== ji}, {exec: ji});
    var Ri = zt("species"), Wi = !c((function () {
        var t = /./;
        return t.exec = function () {
            var t = [];
            return t.groups = {a: "7"}, t
        }, "7" !== "".replace(t, "$<a>")
    })), zi = !c((function () {
        var t = /(?:)/, e = t.exec;
        t.exec = function () {
            return e.apply(this, arguments)
        };
        var r = "ab".split(t);
        return 2 !== r.length || "a" !== r[0] || "b" !== r[1]
    })), Ci = function (t, e, r, n) {
        var i = zt(t), o = !c((function () {
            var e = {};
            return e[i] = function () {
                return 7
            }, 7 != ""[t](e)
        })), s = o && !c((function () {
            var e = !1, r = /a/;
            return r.exec = function () {
                return e = !0, null
            }, "split" === t && (r.constructor = {}, r.constructor[Ri] = function () {
                return r
            }), r[i](""), !e
        }));
        if (!o || !s || "replace" === t && !Wi || "split" === t && !zi) {
            var a = /./[i], l = r(i, ""[t], (function (t, e, r, n, i) {
                return e.exec === ji ? o && !i ? {done: !0, value: a.call(e, r, n)} : {
                    done: !0,
                    value: t.call(r, e, n)
                } : {done: !1}
            })), u = l[0], f = l[1];
            J(String.prototype, t, u), J(RegExp.prototype, i, 2 == e ? function (t, e) {
                return f.call(t, this, e)
            } : function (t) {
                return f.call(t, this)
            }), n && W(RegExp.prototype[i], "sham", !0)
        }
    }, Ni = Ue.charAt, Ii = function (t, e, r) {
        return e + (r ? Ni(t, e).length : 1)
    }, Di = function (t, e) {
        var r = t.exec;
        if ("function" == typeof r) {
            var n = r.call(t, e);
            if ("object" != typeof n) throw TypeError("RegExp exec method returned something other than an Object or null");
            return n
        }
        if ("RegExp" !== v(t)) throw TypeError("RegExp#exec called on incompatible receiver");
        return ji.call(t, e)
    };
    Ci("match", 1, (function (t, e, r) {
        return [function (e) {
            var r = b(this), n = null == e ? void 0 : e[t];
            return void 0 !== n ? n.call(e, r) : new RegExp(e)[t](String(r))
        }, function (t) {
            var n = r(e, t, this);
            if (n.done) return n.value;
            var i = T(t), o = String(this);
            if (!i.global) return Di(i, o);
            var s = i.unicode;
            i.lastIndex = 0;
            for (var a, c = [], l = 0; null !== (a = Di(i, o));) {
                var u = String(a[0]);
                c[l] = u, "" === u && (i.lastIndex = Ii(o, st(i.lastIndex), s)), l++
            }
            return 0 === l ? null : c
        }]
    }));
    var Pi = Math.max, Vi = Math.min, Fi = Math.floor, Bi = /\$([$&'`]|\d\d?|<[^>]*>)/g, Hi = /\$([$&'`]|\d\d?)/g;
    Ci("replace", 2, (function (t, e, r) {
        return [function (r, n) {
            var i = b(this), o = null == r ? void 0 : r[t];
            return void 0 !== o ? o.call(r, i, n) : e.call(String(i), r, n)
        }, function (t, i) {
            var o = r(e, t, this, i);
            if (o.done) return o.value;
            var s = T(t), a = String(this), c = "function" == typeof i;
            c || (i = String(i));
            var l = s.global;
            if (l) {
                var u = s.unicode;
                s.lastIndex = 0
            }
            for (var f = []; ;) {
                var h = Di(s, a);
                if (null === h) break;
                if (f.push(h), !l) break;
                "" === String(h[0]) && (s.lastIndex = Ii(a, st(s.lastIndex), u))
            }
            for (var d, p = "", v = 0, g = 0; g < f.length; g++) {
                h = f[g];
                for (var y = String(h[0]), b = Pi(Vi(it(h.index), a.length), 0), m = [], x = 1; x < h.length; x++) m.push(void 0 === (d = h[x]) ? d : String(d));
                var E = h.groups;
                if (c) {
                    var w = [y].concat(m, b, a);
                    void 0 !== E && w.push(E);
                    var O = String(i.apply(void 0, w))
                } else O = n(y, a, b, m, E, i);
                b >= v && (p += a.slice(v, b) + O, v = b + y.length)
            }
            return p + a.slice(v)
        }];

        function n(t, r, n, i, o, s) {
            var a = n + t.length, c = i.length, l = Hi;
            return void 0 !== o && (o = Mt(o), l = Bi), e.call(s, l, (function (e, s) {
                var l;
                switch (s.charAt(0)) {
                    case"$":
                        return "$";
                    case"&":
                        return t;
                    case"`":
                        return r.slice(0, n);
                    case"'":
                        return r.slice(a);
                    case"<":
                        l = o[s.slice(1, -1)];
                        break;
                    default:
                        var u = +s;
                        if (0 === u) return e;
                        if (u > c) {
                            var f = Fi(u / 10);
                            return 0 === f ? e : f <= c ? void 0 === i[f - 1] ? s.charAt(1) : i[f - 1] + s.charAt(1) : e
                        }
                        l = i[u - 1]
                }
                return void 0 === l ? "" : l
            }))
        }
    }));
    var qi = function (t) {
        return Array.prototype.reduce.call(t, (function (t, e) {
            var r = e.name.match(/data-simplebar-(.+)/);
            if (r) {
                var n = r[1].replace(/\W+(.)/g, (function (t, e) {
                    return e.toUpperCase()
                }));
                switch (e.value) {
                    case"true":
                        t[n] = !0;
                        break;
                    case"false":
                        t[n] = !1;
                        break;
                    case void 0:
                        t[n] = !0;
                        break;
                    default:
                        t[n] = e.value
                }
            }
            return t
        }), {})
    };

    function $i(t) {
        return t && t.ownerDocument && t.ownerDocument.defaultView ? t.ownerDocument.defaultView : window
    }

    function Xi(t) {
        return t && t.ownerDocument ? t.ownerDocument : document
    }

    var Yi = function () {
        function t(e, r) {
            var n = this;
            this.onScroll = function () {
                var t = $i(n.el);
                n.scrollXTicking || (t.requestAnimationFrame(n.scrollX), n.scrollXTicking = !0), n.scrollYTicking || (t.requestAnimationFrame(n.scrollY), n.scrollYTicking = !0)
            }, this.scrollX = function () {
                n.axis.x.isOverflowing && (n.showScrollbar("x"), n.positionScrollbar("x")), n.scrollXTicking = !1
            }, this.scrollY = function () {
                n.axis.y.isOverflowing && (n.showScrollbar("y"), n.positionScrollbar("y")), n.scrollYTicking = !1
            }, this.onMouseEnter = function () {
                n.showScrollbar("x"), n.showScrollbar("y")
            }, this.onMouseMove = function (t) {
                n.mouseX = t.clientX, n.mouseY = t.clientY, (n.axis.x.isOverflowing || n.axis.x.forceVisible) && n.onMouseMoveForAxis("x"), (n.axis.y.isOverflowing || n.axis.y.forceVisible) && n.onMouseMoveForAxis("y")
            }, this.onMouseLeave = function () {
                n.onMouseMove.cancel(), (n.axis.x.isOverflowing || n.axis.x.forceVisible) && n.onMouseLeaveForAxis("x"), (n.axis.y.isOverflowing || n.axis.y.forceVisible) && n.onMouseLeaveForAxis("y"), n.mouseX = -1, n.mouseY = -1
            }, this.onWindowResize = function () {
                n.scrollbarWidth = n.getScrollbarWidth(), n.hideNativeScrollbar()
            }, this.hideScrollbars = function () {
                n.axis.x.track.rect = n.axis.x.track.el.getBoundingClientRect(), n.axis.y.track.rect = n.axis.y.track.el.getBoundingClientRect(), n.isWithinBounds(n.axis.y.track.rect) || (n.axis.y.scrollbar.el.classList.remove(n.classNames.visible), n.axis.y.isVisible = !1), n.isWithinBounds(n.axis.x.track.rect) || (n.axis.x.scrollbar.el.classList.remove(n.classNames.visible), n.axis.x.isVisible = !1)
            }, this.onPointerEvent = function (t) {
                var e, r;
                n.axis.x.track.rect = n.axis.x.track.el.getBoundingClientRect(), n.axis.y.track.rect = n.axis.y.track.el.getBoundingClientRect(), (n.axis.x.isOverflowing || n.axis.x.forceVisible) && (e = n.isWithinBounds(n.axis.x.track.rect)), (n.axis.y.isOverflowing || n.axis.y.forceVisible) && (r = n.isWithinBounds(n.axis.y.track.rect)), (e || r) && (t.preventDefault(), t.stopPropagation(), "mousedown" === t.type && (e && (n.axis.x.scrollbar.rect = n.axis.x.scrollbar.el.getBoundingClientRect(), n.isWithinBounds(n.axis.x.scrollbar.rect) ? n.onDragStart(t, "x") : n.onTrackClick(t, "x")), r && (n.axis.y.scrollbar.rect = n.axis.y.scrollbar.el.getBoundingClientRect(), n.isWithinBounds(n.axis.y.scrollbar.rect) ? n.onDragStart(t, "y") : n.onTrackClick(t, "y"))))
            }, this.drag = function (e) {
                var r = n.axis[n.draggedAxis].track, i = r.rect[n.axis[n.draggedAxis].sizeAttr],
                    o = n.axis[n.draggedAxis].scrollbar, s = n.contentWrapperEl[n.axis[n.draggedAxis].scrollSizeAttr],
                    a = parseInt(n.elStyles[n.axis[n.draggedAxis].sizeAttr], 10);
                e.preventDefault(), e.stopPropagation();
                var c = (("y" === n.draggedAxis ? e.pageY : e.pageX) - r.rect[n.axis[n.draggedAxis].offsetAttr] - n.axis[n.draggedAxis].dragOffset) / (i - o.size) * (s - a);
                "x" === n.draggedAxis && (c = n.isRtl && t.getRtlHelpers().isRtlScrollbarInverted ? c - (i + o.size) : c, c = n.isRtl && t.getRtlHelpers().isRtlScrollingInverted ? -c : c), n.contentWrapperEl[n.axis[n.draggedAxis].scrollOffsetAttr] = c
            }, this.onEndDrag = function (t) {
                var e = Xi(n.el), r = $i(n.el);
                t.preventDefault(), t.stopPropagation(), n.el.classList.remove(n.classNames.dragging), e.removeEventListener("mousemove", n.drag, !0), e.removeEventListener("mouseup", n.onEndDrag, !0), n.removePreventClickId = r.setTimeout((function () {
                    e.removeEventListener("click", n.preventClick, !0), e.removeEventListener("dblclick", n.preventClick, !0), n.removePreventClickId = null
                }))
            }, this.preventClick = function (t) {
                t.preventDefault(), t.stopPropagation()
            }, this.el = e, this.minScrollbarWidth = 20, this.options = Object.assign({}, t.defaultOptions, {}, r), this.classNames = Object.assign({}, t.defaultOptions.classNames, {}, this.options.classNames), this.axis = {
                x: {
                    scrollOffsetAttr: "scrollLeft",
                    sizeAttr: "width",
                    scrollSizeAttr: "scrollWidth",
                    offsetSizeAttr: "offsetWidth",
                    offsetAttr: "left",
                    overflowAttr: "overflowX",
                    dragOffset: 0,
                    isOverflowing: !0,
                    isVisible: !1,
                    forceVisible: !1,
                    track: {},
                    scrollbar: {}
                },
                y: {
                    scrollOffsetAttr: "scrollTop",
                    sizeAttr: "height",
                    scrollSizeAttr: "scrollHeight",
                    offsetSizeAttr: "offsetHeight",
                    offsetAttr: "top",
                    overflowAttr: "overflowY",
                    dragOffset: 0,
                    isOverflowing: !0,
                    isVisible: !1,
                    forceVisible: !1,
                    track: {},
                    scrollbar: {}
                }
            }, this.removePreventClickId = null, t.instances.has(this.el) || (this.recalculate = Gr(this.recalculate.bind(this), 64), this.onMouseMove = Gr(this.onMouseMove.bind(this), 64), this.hideScrollbars = dn(this.hideScrollbars.bind(this), this.options.timeout), this.onWindowResize = dn(this.onWindowResize.bind(this), 64, {leading: !0}), t.getRtlHelpers = Hn(t.getRtlHelpers), this.init())
        }

        t.getRtlHelpers = function () {
            var e = document.createElement("div");
            e.innerHTML = '<div class="hs-dummy-scrollbar-size"><div style="height: 200%; width: 200%; margin: 10px 0;"></div></div>';
            var r = e.firstElementChild;
            document.body.appendChild(r);
            var n = r.firstElementChild;
            r.scrollLeft = 0;
            var i = t.getOffset(r), o = t.getOffset(n);
            r.scrollLeft = 999;
            var s = t.getOffset(n);
            return {
                isRtlScrollingInverted: i.left !== o.left && o.left - s.left != 0,
                isRtlScrollbarInverted: i.left !== o.left
            }
        }, t.getOffset = function (t) {
            var e = t.getBoundingClientRect(), r = Xi(t), n = $i(t);
            return {
                top: e.top + (n.pageYOffset || r.documentElement.scrollTop),
                left: e.left + (n.pageXOffset || r.documentElement.scrollLeft)
            }
        };
        var e = t.prototype;
        return e.init = function () {
            t.instances.set(this.el, this), Yt && (this.initDOM(), this.scrollbarWidth = this.getScrollbarWidth(), this.recalculate(), this.initListeners())
        }, e.initDOM = function () {
            var t = this;
            Xi(this.el);
            if (Array.prototype.filter.call(this.el.children, (function (e) {
                return e.classList.contains(t.classNames.wrapper)
            })).length) this.wrapperEl = this.el.querySelector("." + this.classNames.wrapper), this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector("." + this.classNames.contentWrapper), this.contentEl = this.options.contentNode || this.el.querySelector("." + this.classNames.contentEl), this.offsetEl = this.el.querySelector("." + this.classNames.offset), this.maskEl = this.el.querySelector("." + this.classNames.mask), this.placeholderEl = this.findChild(this.wrapperEl, "." + this.classNames.placeholder), this.heightAutoObserverWrapperEl = this.el.querySelector("." + this.classNames.heightAutoObserverWrapperEl), this.heightAutoObserverEl = this.el.querySelector("." + this.classNames.heightAutoObserverEl), this.axis.x.track.el = this.findChild(this.el, "." + this.classNames.track + "." + this.classNames.horizontal), this.axis.y.track.el = this.findChild(this.el, "." + this.classNames.track + "." + this.classNames.vertical); else {
                for (this.wrapperEl = document.createElement("div"), this.contentWrapperEl = document.createElement("div"), this.offsetEl = document.createElement("div"), this.maskEl = document.createElement("div"), this.contentEl = document.createElement("div"), this.placeholderEl = document.createElement("div"), this.heightAutoObserverWrapperEl = document.createElement("div"), this.heightAutoObserverEl = document.createElement("div"), this.wrapperEl.classList.add(this.classNames.wrapper), this.contentWrapperEl.classList.add(this.classNames.contentWrapper), this.offsetEl.classList.add(this.classNames.offset), this.maskEl.classList.add(this.classNames.mask), this.contentEl.classList.add(this.classNames.contentEl), this.placeholderEl.classList.add(this.classNames.placeholder), this.heightAutoObserverWrapperEl.classList.add(this.classNames.heightAutoObserverWrapperEl), this.heightAutoObserverEl.classList.add(this.classNames.heightAutoObserverEl); this.el.firstChild;) this.contentEl.appendChild(this.el.firstChild);
                this.contentWrapperEl.appendChild(this.contentEl), this.offsetEl.appendChild(this.contentWrapperEl), this.maskEl.appendChild(this.offsetEl), this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl), this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl), this.wrapperEl.appendChild(this.maskEl), this.wrapperEl.appendChild(this.placeholderEl), this.el.appendChild(this.wrapperEl)
            }
            if (!this.axis.x.track.el || !this.axis.y.track.el) {
                var e = document.createElement("div"), r = document.createElement("div");
                e.classList.add(this.classNames.track), r.classList.add(this.classNames.scrollbar), e.appendChild(r), this.axis.x.track.el = e.cloneNode(!0), this.axis.x.track.el.classList.add(this.classNames.horizontal), this.axis.y.track.el = e.cloneNode(!0), this.axis.y.track.el.classList.add(this.classNames.vertical), this.el.appendChild(this.axis.x.track.el), this.el.appendChild(this.axis.y.track.el)
            }
            this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector("." + this.classNames.scrollbar), this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector("." + this.classNames.scrollbar), this.options.autoHide || (this.axis.x.scrollbar.el.classList.add(this.classNames.visible), this.axis.y.scrollbar.el.classList.add(this.classNames.visible)), this.el.setAttribute("data-simplebar", "init")
        }, e.initListeners = function () {
            var t = this, e = $i(this.el);
            this.options.autoHide && this.el.addEventListener("mouseenter", this.onMouseEnter), ["mousedown", "click", "dblclick"].forEach((function (e) {
                t.el.addEventListener(e, t.onPointerEvent, !0)
            })), ["touchstart", "touchend", "touchmove"].forEach((function (e) {
                t.el.addEventListener(e, t.onPointerEvent, {capture: !0, passive: !0})
            })), this.el.addEventListener("mousemove", this.onMouseMove), this.el.addEventListener("mouseleave", this.onMouseLeave), this.contentWrapperEl.addEventListener("scroll", this.onScroll), e.addEventListener("resize", this.onWindowResize);
            var r = !1, n = e.ResizeObserver || di;
            this.resizeObserver = new n((function () {
                r && t.recalculate()
            })), this.resizeObserver.observe(this.el), this.resizeObserver.observe(this.contentEl), e.requestAnimationFrame((function () {
                r = !0
            })), this.mutationObserver = new e.MutationObserver(this.recalculate), this.mutationObserver.observe(this.contentEl, {
                childList: !0,
                subtree: !0,
                characterData: !0
            })
        }, e.recalculate = function () {
            var t = $i(this.el);
            this.elStyles = t.getComputedStyle(this.el), this.isRtl = "rtl" === this.elStyles.direction;
            var e = this.heightAutoObserverEl.offsetHeight <= 1, r = this.heightAutoObserverEl.offsetWidth <= 1,
                n = this.contentEl.offsetWidth, i = this.contentWrapperEl.offsetWidth, o = this.elStyles.overflowX,
                s = this.elStyles.overflowY;
            this.contentEl.style.padding = this.elStyles.paddingTop + " " + this.elStyles.paddingRight + " " + this.elStyles.paddingBottom + " " + this.elStyles.paddingLeft, this.wrapperEl.style.margin = "-" + this.elStyles.paddingTop + " -" + this.elStyles.paddingRight + " -" + this.elStyles.paddingBottom + " -" + this.elStyles.paddingLeft;
            var a = this.contentEl.scrollHeight, c = this.contentEl.scrollWidth;
            this.contentWrapperEl.style.height = e ? "auto" : "100%", this.placeholderEl.style.width = r ? n + "px" : "auto", this.placeholderEl.style.height = a + "px";
            var l = this.contentWrapperEl.offsetHeight;
            this.axis.x.isOverflowing = c > n, this.axis.y.isOverflowing = a > l, this.axis.x.isOverflowing = "hidden" !== o && this.axis.x.isOverflowing, this.axis.y.isOverflowing = "hidden" !== s && this.axis.y.isOverflowing, this.axis.x.forceVisible = "x" === this.options.forceVisible || !0 === this.options.forceVisible, this.axis.y.forceVisible = "y" === this.options.forceVisible || !0 === this.options.forceVisible, this.hideNativeScrollbar();
            var u = this.axis.x.isOverflowing ? this.scrollbarWidth : 0,
                f = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
            this.axis.x.isOverflowing = this.axis.x.isOverflowing && c > i - f, this.axis.y.isOverflowing = this.axis.y.isOverflowing && a > l - u, this.axis.x.scrollbar.size = this.getScrollbarSize("x"), this.axis.y.scrollbar.size = this.getScrollbarSize("y"), this.axis.x.scrollbar.el.style.width = this.axis.x.scrollbar.size + "px", this.axis.y.scrollbar.el.style.height = this.axis.y.scrollbar.size + "px", this.positionScrollbar("x"), this.positionScrollbar("y"), this.toggleTrackVisibility("x"), this.toggleTrackVisibility("y")
        }, e.getScrollbarSize = function (t) {
            if (void 0 === t && (t = "y"), !this.axis[t].isOverflowing) return 0;
            var e, r = this.contentEl[this.axis[t].scrollSizeAttr],
                n = this.axis[t].track.el[this.axis[t].offsetSizeAttr], i = n / r;
            return e = Math.max(~~(i * n), this.options.scrollbarMinSize), this.options.scrollbarMaxSize && (e = Math.min(e, this.options.scrollbarMaxSize)), e
        }, e.positionScrollbar = function (e) {
            if (void 0 === e && (e = "y"), this.axis[e].isOverflowing) {
                var r = this.contentWrapperEl[this.axis[e].scrollSizeAttr],
                    n = this.axis[e].track.el[this.axis[e].offsetSizeAttr],
                    i = parseInt(this.elStyles[this.axis[e].sizeAttr], 10), o = this.axis[e].scrollbar,
                    s = this.contentWrapperEl[this.axis[e].scrollOffsetAttr],
                    a = (s = "x" === e && this.isRtl && t.getRtlHelpers().isRtlScrollingInverted ? -s : s) / (r - i),
                    c = ~~((n - o.size) * a);
                c = "x" === e && this.isRtl && t.getRtlHelpers().isRtlScrollbarInverted ? c + (n - o.size) : c, o.el.style.transform = "x" === e ? "translate3d(" + c + "px, 0, 0)" : "translate3d(0, " + c + "px, 0)"
            }
        }, e.toggleTrackVisibility = function (t) {
            void 0 === t && (t = "y");
            var e = this.axis[t].track.el, r = this.axis[t].scrollbar.el;
            this.axis[t].isOverflowing || this.axis[t].forceVisible ? (e.style.visibility = "visible", this.contentWrapperEl.style[this.axis[t].overflowAttr] = "scroll") : (e.style.visibility = "hidden", this.contentWrapperEl.style[this.axis[t].overflowAttr] = "hidden"), this.axis[t].isOverflowing ? r.style.display = "block" : r.style.display = "none"
        }, e.hideNativeScrollbar = function () {
            this.offsetEl.style[this.isRtl ? "left" : "right"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-" + this.scrollbarWidth + "px" : 0, this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-" + this.scrollbarWidth + "px" : 0
        }, e.onMouseMoveForAxis = function (t) {
            void 0 === t && (t = "y"), this.axis[t].track.rect = this.axis[t].track.el.getBoundingClientRect(), this.axis[t].scrollbar.rect = this.axis[t].scrollbar.el.getBoundingClientRect(), this.isWithinBounds(this.axis[t].scrollbar.rect) ? this.axis[t].scrollbar.el.classList.add(this.classNames.hover) : this.axis[t].scrollbar.el.classList.remove(this.classNames.hover), this.isWithinBounds(this.axis[t].track.rect) ? (this.showScrollbar(t), this.axis[t].track.el.classList.add(this.classNames.hover)) : this.axis[t].track.el.classList.remove(this.classNames.hover)
        }, e.onMouseLeaveForAxis = function (t) {
            void 0 === t && (t = "y"), this.axis[t].track.el.classList.remove(this.classNames.hover), this.axis[t].scrollbar.el.classList.remove(this.classNames.hover)
        }, e.showScrollbar = function (t) {
            void 0 === t && (t = "y");
            var e = this.axis[t].scrollbar.el;
            this.axis[t].isVisible || (e.classList.add(this.classNames.visible), this.axis[t].isVisible = !0), this.options.autoHide && this.hideScrollbars()
        }, e.onDragStart = function (t, e) {
            void 0 === e && (e = "y");
            var r = Xi(this.el), n = $i(this.el), i = this.axis[e].scrollbar, o = "y" === e ? t.pageY : t.pageX;
            this.axis[e].dragOffset = o - i.rect[this.axis[e].offsetAttr], this.draggedAxis = e, this.el.classList.add(this.classNames.dragging), r.addEventListener("mousemove", this.drag, !0), r.addEventListener("mouseup", this.onEndDrag, !0), null === this.removePreventClickId ? (r.addEventListener("click", this.preventClick, !0), r.addEventListener("dblclick", this.preventClick, !0)) : (n.clearTimeout(this.removePreventClickId), this.removePreventClickId = null)
        }, e.onTrackClick = function (t, e) {
            var r = this;
            if (void 0 === e && (e = "y"), this.options.clickOnTrack) {
                var n = $i(this.el);
                this.axis[e].scrollbar.rect = this.axis[e].scrollbar.el.getBoundingClientRect();
                var i = this.axis[e].scrollbar.rect[this.axis[e].offsetAttr],
                    o = parseInt(this.elStyles[this.axis[e].sizeAttr], 10),
                    s = this.contentWrapperEl[this.axis[e].scrollOffsetAttr],
                    a = ("y" === e ? this.mouseY - i : this.mouseX - i) < 0 ? -1 : 1, c = -1 === a ? s - o : s + o;
                !function t() {
                    var i, o;
                    -1 === a ? s > c && (s -= 40, r.contentWrapperEl.scrollTo(((i = {})[r.axis[e].offsetAttr] = s, i)), n.requestAnimationFrame(t)) : s < c && (s += 40, r.contentWrapperEl.scrollTo(((o = {})[r.axis[e].offsetAttr] = s, o)), n.requestAnimationFrame(t))
                }()
            }
        }, e.getContentElement = function () {
            return this.contentEl
        }, e.getScrollElement = function () {
            return this.contentWrapperEl
        }, e.getScrollbarWidth = function () {
            try {
                return "none" === getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar").display || "scrollbarWidth" in document.documentElement.style || "-ms-overflow-style" in document.documentElement.style ? 0 : gi()
            } catch (t) {
                return gi()
            }
        }, e.removeListeners = function () {
            var t = this, e = $i(this.el);
            this.options.autoHide && this.el.removeEventListener("mouseenter", this.onMouseEnter), ["mousedown", "click", "dblclick"].forEach((function (e) {
                t.el.removeEventListener(e, t.onPointerEvent, !0)
            })), ["touchstart", "touchend", "touchmove"].forEach((function (e) {
                t.el.removeEventListener(e, t.onPointerEvent, {capture: !0, passive: !0})
            })), this.el.removeEventListener("mousemove", this.onMouseMove), this.el.removeEventListener("mouseleave", this.onMouseLeave), this.contentWrapperEl.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onWindowResize), this.mutationObserver.disconnect(), this.resizeObserver.disconnect(), this.recalculate.cancel(), this.onMouseMove.cancel(), this.hideScrollbars.cancel(), this.onWindowResize.cancel()
        }, e.unMount = function () {
            this.removeListeners(), t.instances.delete(this.el)
        }, e.isWithinBounds = function (t) {
            return this.mouseX >= t.left && this.mouseX <= t.left + t.width && this.mouseY >= t.top && this.mouseY <= t.top + t.height
        }, e.findChild = function (t, e) {
            var r = t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.msMatchesSelector;
            return Array.prototype.filter.call(t.children, (function (t) {
                return r.call(t, e)
            }))[0]
        }, t
    }();
    return Yi.defaultOptions = {
        autoHide: !0,
        forceVisible: !1,
        clickOnTrack: !0,
        classNames: {
            contentEl: "simplebar-content",
            contentWrapper: "simplebar-content-wrapper",
            offset: "simplebar-offset",
            mask: "simplebar-mask",
            wrapper: "simplebar-wrapper",
            placeholder: "simplebar-placeholder",
            scrollbar: "simplebar-scrollbar",
            track: "simplebar-track",
            heightAutoObserverWrapperEl: "simplebar-height-auto-observer-wrapper",
            heightAutoObserverEl: "simplebar-height-auto-observer",
            visible: "simplebar-visible",
            horizontal: "simplebar-horizontal",
            vertical: "simplebar-vertical",
            hover: "simplebar-hover",
            dragging: "simplebar-dragging"
        },
        scrollbarMinSize: 25,
        scrollbarMaxSize: 0,
        timeout: 1e3
    }, Yi.instances = new WeakMap, Yi.initDOMLoadedElements = function () {
        document.removeEventListener("DOMContentLoaded", this.initDOMLoadedElements), window.removeEventListener("load", this.initDOMLoadedElements), Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]:not([data-simplebar="init"])'), (function (t) {
            Yi.instances.has(t) || new Yi(t, qi(t.attributes))
        }))
    }, Yi.removeObserver = function () {
        this.globalObserver.disconnect()
    }, Yi.initHtmlApi = function () {
        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this), "undefined" != typeof MutationObserver && (this.globalObserver = new MutationObserver(Yi.handleMutations), this.globalObserver.observe(document, {
            childList: !0,
            subtree: !0
        })), "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(this.initDOMLoadedElements) : (document.addEventListener("DOMContentLoaded", this.initDOMLoadedElements), window.addEventListener("load", this.initDOMLoadedElements))
    }, Yi.handleMutations = function (t) {
        t.forEach((function (t) {
            Array.prototype.forEach.call(t.addedNodes, (function (t) {
                1 === t.nodeType && (t.hasAttribute("data-simplebar") ? !Yi.instances.has(t) && new Yi(t, qi(t.attributes)) : Array.prototype.forEach.call(t.querySelectorAll('[data-simplebar]:not([data-simplebar="init"])'), (function (t) {
                    !Yi.instances.has(t) && new Yi(t, qi(t.attributes))
                })))
            })), Array.prototype.forEach.call(t.removedNodes, (function (t) {
                1 === t.nodeType && (t.hasAttribute('[data-simplebar="init"]') ? Yi.instances.has(t) && Yi.instances.get(t).unMount() : Array.prototype.forEach.call(t.querySelectorAll('[data-simplebar="init"]'), (function (t) {
                    Yi.instances.has(t) && Yi.instances.get(t).unMount()
                })))
            }))
        }))
    }, Yi.getOptions = qi, Yt && Yi.initHtmlApi(), Yi
}));

!function (t, e) {
    "use strict";
    "function" == typeof define && define.amd ? define([], function () {
        return t.Waves = e.call(t), t.Waves
    }) : "object" == typeof exports ? module.exports = e.call(t) : t.Waves = e.call(t)
}("object" == typeof global ? global : this, function () {
    "use strict";

    function t(t) {
        return null !== t && t === t.window
    }

    function e(e) {
        return t(e) ? e : 9 === e.nodeType && e.defaultView
    }

    function n(t) {
        var e = typeof t;
        return "function" === e || "object" === e && !!t
    }

    function o(t) {
        return n(t) && t.nodeType > 0
    }

    function a(t) {
        var e = f.call(t);
        return "[object String]" === e ? d(t) : n(t) && /^\[object (Array|HTMLCollection|NodeList|Object)\]$/.test(e) && t.hasOwnProperty("length") ? t : o(t) ? [t] : []
    }

    function i(t) {
        var n, o, a = {top: 0, left: 0}, i = t && t.ownerDocument;
        return n = i.documentElement, void 0 !== t.getBoundingClientRect && (a = t.getBoundingClientRect()), o = e(i), {
            top: a.top + o.pageYOffset - n.clientTop,
            left: a.left + o.pageXOffset - n.clientLeft
        }
    }

    function r(t) {
        var e = "";
        for (var n in t) t.hasOwnProperty(n) && (e += n + ":" + t[n] + ";");
        return e
    }

    function s(t, e, n) {
        if (n) {
            n.classList.remove("waves-rippling");
            var o = n.getAttribute("data-x"), a = n.getAttribute("data-y"), i = n.getAttribute("data-scale"),
                s = n.getAttribute("data-translate"), u = 350 - (Date.now() - Number(n.getAttribute("data-hold")));
            u < 0 && (u = 0), "mousemove" === t.type && (u = 150);
            var c = "mousemove" === t.type ? 2500 : v.duration;
            setTimeout(function () {
                var t = {
                    top: a + "px",
                    left: o + "px",
                    opacity: "0",
                    "-webkit-transition-duration": c + "ms",
                    "-moz-transition-duration": c + "ms",
                    "-o-transition-duration": c + "ms",
                    "transition-duration": c + "ms",
                    "-webkit-transform": i + " " + s,
                    "-moz-transform": i + " " + s,
                    "-ms-transform": i + " " + s,
                    "-o-transform": i + " " + s,
                    transform: i + " " + s
                };
                n.setAttribute("style", r(t)), setTimeout(function () {
                    try {
                        e.removeChild(n)
                    } catch (t) {
                        return !1
                    }
                }, c)
            }, u)
        }
    }

    function u(t) {
        if (!1 === h.allowEvent(t)) return null;
        for (var e = null, n = t.target || t.srcElement; n.parentElement;) {
            if (!(n instanceof SVGElement) && n.classList.contains("waves-effect")) {
                e = n;
                break
            }
            n = n.parentElement
        }
        return e
    }

    function c(t) {
        var e = u(t);
        if (null !== e) {
            if (e.disabled || e.getAttribute("disabled") || e.classList.contains("disabled")) return;
            if (h.registerEvent(t), "touchstart" === t.type && v.delay) {
                var n = !1, o = setTimeout(function () {
                    o = null, v.show(t, e)
                }, v.delay), a = function (a) {
                    o && (clearTimeout(o), o = null, v.show(t, e)), n || (n = !0, v.hide(a, e)), r()
                }, i = function (t) {
                    o && (clearTimeout(o), o = null), a(t), r()
                };
                e.addEventListener("touchmove", i, !1), e.addEventListener("touchend", a, !1), e.addEventListener("touchcancel", a, !1);
                var r = function () {
                    e.removeEventListener("touchmove", i), e.removeEventListener("touchend", a), e.removeEventListener("touchcancel", a)
                }
            } else v.show(t, e), m && (e.addEventListener("touchend", v.hide, !1), e.addEventListener("touchcancel", v.hide, !1)), e.addEventListener("mouseup", v.hide, !1), e.addEventListener("mouseleave", v.hide, !1)
        }
    }

    var l = l || {}, d = document.querySelectorAll.bind(document), f = Object.prototype.toString,
        m = "ontouchstart" in window, v = {
            duration: 750, delay: 200, show: function (t, e, n) {
                if (2 === t.button) return !1;
                e = e || this;
                var o = document.createElement("div");
                o.className = "waves-ripple waves-rippling", e.appendChild(o);
                var a = i(e), s = 0, u = 0;
                "touches" in t && t.touches.length ? (s = t.touches[0].pageY - a.top, u = t.touches[0].pageX - a.left) : (s = t.pageY - a.top, u = t.pageX - a.left), u = u >= 0 ? u : 0, s = s >= 0 ? s : 0;
                var c = "scale(" + e.clientWidth / 100 * 3 + ")", l = "translate(0,0)";
                n && (l = "translate(" + n.x + "px, " + n.y + "px)"), o.setAttribute("data-hold", Date.now()), o.setAttribute("data-x", u), o.setAttribute("data-y", s), o.setAttribute("data-scale", c), o.setAttribute("data-translate", l);
                var d = {top: s + "px", left: u + "px"};
                o.classList.add("waves-notransition"), o.setAttribute("style", r(d)), o.classList.remove("waves-notransition"), d["-webkit-transform"] = c + " " + l, d["-moz-transform"] = c + " " + l, d["-ms-transform"] = c + " " + l, d["-o-transform"] = c + " " + l, d.transform = c + " " + l, d.opacity = "1";
                var f = "mousemove" === t.type ? 2500 : v.duration;
                d["-webkit-transition-duration"] = f + "ms", d["-moz-transition-duration"] = f + "ms", d["-o-transition-duration"] = f + "ms", d["transition-duration"] = f + "ms", o.setAttribute("style", r(d))
            }, hide: function (t, e) {
                for (var n = (e = e || this).getElementsByClassName("waves-rippling"), o = 0, a = n.length; o < a; o++) s(t, e, n[o]);
                m && (e.removeEventListener("touchend", v.hide), e.removeEventListener("touchcancel", v.hide)), e.removeEventListener("mouseup", v.hide), e.removeEventListener("mouseleave", v.hide)
            }
        }, p = {
            input: function (t) {
                var e = t.parentNode;
                if ("i" !== e.tagName.toLowerCase() || !e.classList.contains("waves-effect")) {
                    var n = document.createElement("i");
                    n.className = t.className + " waves-input-wrapper", t.className = "waves-button-input", e.replaceChild(n, t), n.appendChild(t);
                    var o = window.getComputedStyle(t, null), a = o.color, i = o.backgroundColor;
                    n.setAttribute("style", "color:" + a + ";background:" + i), t.setAttribute("style", "background-color:rgba(0,0,0,0);")
                }
            }, img: function (t) {
                var e = t.parentNode;
                if ("i" !== e.tagName.toLowerCase() || !e.classList.contains("waves-effect")) {
                    var n = document.createElement("i");
                    e.replaceChild(n, t), n.appendChild(t)
                }
            }
        }, h = {
            touches: 0, allowEvent: function (t) {
                var e = !0;
                return /^(mousedown|mousemove)$/.test(t.type) && h.touches && (e = !1), e
            }, registerEvent: function (t) {
                var e = t.type;
                "touchstart" === e ? h.touches += 1 : /^(touchend|touchcancel)$/.test(e) && setTimeout(function () {
                    h.touches && (h.touches -= 1)
                }, 500)
            }
        };
    return l.init = function (t) {
        var e = document.body;
        "duration" in (t = t || {}) && (v.duration = t.duration), "delay" in t && (v.delay = t.delay), m && (e.addEventListener("touchstart", c, !1), e.addEventListener("touchcancel", h.registerEvent, !1), e.addEventListener("touchend", h.registerEvent, !1)), e.addEventListener("mousedown", c, !1)
    }, l.attach = function (t, e) {
        t = a(t), "[object Array]" === f.call(e) && (e = e.join(" ")), e = e ? " " + e : "";
        for (var n, o, i = 0, r = t.length; i < r; i++) o = (n = t[i]).tagName.toLowerCase(), -1 !== ["input", "img"].indexOf(o) && (p[o](n), n = n.parentElement), -1 === n.className.indexOf("waves-effect") && (n.className += " waves-effect" + e)
    }, l.ripple = function (t, e) {
        var n = (t = a(t)).length;
        if (e = e || {}, e.wait = e.wait || 0, e.position = e.position || null, n) for (var o, r, s, u = {}, c = 0, l = {
            type: "mousedown",
            button: 1
        }; c < n; c++) if (o = t[c], r = e.position || {
            x: o.clientWidth / 2,
            y: o.clientHeight / 2
        }, s = i(o), u.x = s.left + r.x, u.y = s.top + r.y, l.pageX = u.x, l.pageY = u.y, v.show(l, o), e.wait >= 0 && null !== e.wait) {
            var d = {type: "mouseup", button: 1};
            setTimeout(function (t, e) {
                return function () {
                    v.hide(t, e)
                }
            }(d, o), e.wait)
        }
    }, l.calm = function (t) {
        for (var e = {type: "mouseup", button: 1}, n = 0, o = (t = a(t)).length; n < o; n++) v.hide(e, t[n])
    }, l.displayEffect = function (t) {
        l.init(t)
    }, l
});
//# sourceMappingURL=waves.min.js.map
/*!
Waypoints - 4.0.1
Copyright  2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function () {
    "use strict";

    function t(o) {
        if (!o) throw new Error("No options passed to Waypoint constructor");
        if (!o.element) throw new Error("No element option passed to Waypoint constructor");
        if (!o.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + e, this.options = t.Adapter.extend({}, t.defaults, o), this.element = this.options.element, this.adapter = new t.Adapter(this.element), this.callback = o.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, e += 1
    }

    var e = 0, i = {};
    t.prototype.queueTrigger = function (t) {
        this.group.queueTrigger(this, t)
    }, t.prototype.trigger = function (t) {
        this.enabled && this.callback && this.callback.apply(this, t)
    }, t.prototype.destroy = function () {
        this.context.remove(this), this.group.remove(this), delete i[this.key]
    }, t.prototype.disable = function () {
        return this.enabled = !1, this
    }, t.prototype.enable = function () {
        return this.context.refresh(), this.enabled = !0, this
    }, t.prototype.next = function () {
        return this.group.next(this)
    }, t.prototype.previous = function () {
        return this.group.previous(this)
    }, t.invokeAll = function (t) {
        var e = [];
        for (var o in i) e.push(i[o]);
        for (var n = 0, r = e.length; r > n; n++) e[n][t]()
    }, t.destroyAll = function () {
        t.invokeAll("destroy")
    }, t.disableAll = function () {
        t.invokeAll("disable")
    }, t.enableAll = function () {
        t.Context.refreshAll();
        for (var e in i) i[e].enabled = !0;
        return this
    }, t.refreshAll = function () {
        t.Context.refreshAll()
    }, t.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight
    }, t.viewportWidth = function () {
        return document.documentElement.clientWidth
    }, t.adapters = [], t.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, t.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight()
        }, "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }, window.Waypoint = t
}(), function () {
    "use strict";

    function t(t) {
        window.setTimeout(t, 1e3 / 60)
    }

    function e(t) {
        this.element = t, this.Adapter = n.Adapter, this.adapter = new this.Adapter(t), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, t.waypointContextKey = this.key, o[t.waypointContextKey] = this, i += 1, n.windowContext || (n.windowContext = !0, n.windowContext = new e(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
    }

    var i = 0, o = {}, n = window.Waypoint, r = window.onload;
    e.prototype.add = function (t) {
        var e = t.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[e][t.key] = t, this.refresh()
    }, e.prototype.checkEmpty = function () {
        var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            e = this.Adapter.isEmptyObject(this.waypoints.vertical), i = this.element == this.element.window;
        t && e && !i && (this.adapter.off(".waypoints"), delete o[this.key])
    }, e.prototype.createThrottledResizeHandler = function () {
        function t() {
            e.handleResize(), e.didResize = !1
        }

        var e = this;
        this.adapter.on("resize.waypoints", function () {
            e.didResize || (e.didResize = !0, n.requestAnimationFrame(t))
        })
    }, e.prototype.createThrottledScrollHandler = function () {
        function t() {
            e.handleScroll(), e.didScroll = !1
        }

        var e = this;
        this.adapter.on("scroll.waypoints", function () {
            (!e.didScroll || n.isTouch) && (e.didScroll = !0, n.requestAnimationFrame(t))
        })
    }, e.prototype.handleResize = function () {
        n.Context.refreshAll()
    }, e.prototype.handleScroll = function () {
        var t = {}, e = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left"
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up"
            }
        };
        for (var i in e) {
            var o = e[i], n = o.newScroll > o.oldScroll, r = n ? o.forward : o.backward;
            for (var s in this.waypoints[i]) {
                var a = this.waypoints[i][s];
                if (null !== a.triggerPoint) {
                    var l = o.oldScroll < a.triggerPoint, h = o.newScroll >= a.triggerPoint, p = l && h, u = !l && !h;
                    (p || u) && (a.queueTrigger(r), t[a.group.id] = a.group)
                }
            }
        }
        for (var c in t) t[c].flushTriggers();
        this.oldScroll = {x: e.horizontal.newScroll, y: e.vertical.newScroll}
    }, e.prototype.innerHeight = function () {
        return this.element == this.element.window ? n.viewportHeight() : this.adapter.innerHeight()
    }, e.prototype.remove = function (t) {
        delete this.waypoints[t.axis][t.key], this.checkEmpty()
    }, e.prototype.innerWidth = function () {
        return this.element == this.element.window ? n.viewportWidth() : this.adapter.innerWidth()
    }, e.prototype.destroy = function () {
        var t = [];
        for (var e in this.waypoints) for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
        for (var o = 0, n = t.length; n > o; o++) t[o].destroy()
    }, e.prototype.refresh = function () {
        var t, e = this.element == this.element.window, i = e ? void 0 : this.adapter.offset(), o = {};
        this.handleScroll(), t = {
            horizontal: {
                contextOffset: e ? 0 : i.left,
                contextScroll: e ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: e ? 0 : i.top,
                contextScroll: e ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        };
        for (var r in t) {
            var s = t[r];
            for (var a in this.waypoints[r]) {
                var l, h, p, u, c, d = this.waypoints[r][a], f = d.options.offset, w = d.triggerPoint, y = 0,
                    g = null == w;
                d.element !== d.element.window && (y = d.adapter.offset()[s.offsetProp]), "function" == typeof f ? f = f.apply(d) : "string" == typeof f && (f = parseFloat(f), d.options.offset.indexOf("%") > -1 && (f = Math.ceil(s.contextDimension * f / 100))), l = s.contextScroll - s.contextOffset, d.triggerPoint = Math.floor(y + l - f), h = w < s.oldScroll, p = d.triggerPoint >= s.oldScroll, u = h && p, c = !h && !p, !g && u ? (d.queueTrigger(s.backward), o[d.group.id] = d.group) : !g && c ? (d.queueTrigger(s.forward), o[d.group.id] = d.group) : g && s.oldScroll >= d.triggerPoint && (d.queueTrigger(s.forward), o[d.group.id] = d.group)
            }
        }
        return n.requestAnimationFrame(function () {
            for (var t in o) o[t].flushTriggers()
        }), this
    }, e.findOrCreateByElement = function (t) {
        return e.findByElement(t) || new e(t)
    }, e.refreshAll = function () {
        for (var t in o) o[t].refresh()
    }, e.findByElement = function (t) {
        return o[t.waypointContextKey]
    }, window.onload = function () {
        r && r(), e.refreshAll()
    }, n.requestAnimationFrame = function (e) {
        var i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t;
        i.call(window, e)
    }, n.Context = e
}(), function () {
    "use strict";

    function t(t, e) {
        return t.triggerPoint - e.triggerPoint
    }

    function e(t, e) {
        return e.triggerPoint - t.triggerPoint
    }

    function i(t) {
        this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), o[this.axis][this.name] = this
    }

    var o = {vertical: {}, horizontal: {}}, n = window.Waypoint;
    i.prototype.add = function (t) {
        this.waypoints.push(t)
    }, i.prototype.clearTriggerQueues = function () {
        this.triggerQueues = {up: [], down: [], left: [], right: []}
    }, i.prototype.flushTriggers = function () {
        for (var i in this.triggerQueues) {
            var o = this.triggerQueues[i], n = "up" === i || "left" === i;
            o.sort(n ? e : t);
            for (var r = 0, s = o.length; s > r; r += 1) {
                var a = o[r];
                (a.options.continuous || r === o.length - 1) && a.trigger([i])
            }
        }
        this.clearTriggerQueues()
    }, i.prototype.next = function (e) {
        this.waypoints.sort(t);
        var i = n.Adapter.inArray(e, this.waypoints), o = i === this.waypoints.length - 1;
        return o ? null : this.waypoints[i + 1]
    }, i.prototype.previous = function (e) {
        this.waypoints.sort(t);
        var i = n.Adapter.inArray(e, this.waypoints);
        return i ? this.waypoints[i - 1] : null
    }, i.prototype.queueTrigger = function (t, e) {
        this.triggerQueues[e].push(t)
    }, i.prototype.remove = function (t) {
        var e = n.Adapter.inArray(t, this.waypoints);
        e > -1 && this.waypoints.splice(e, 1)
    }, i.prototype.first = function () {
        return this.waypoints[0]
    }, i.prototype.last = function () {
        return this.waypoints[this.waypoints.length - 1]
    }, i.findOrCreate = function (t) {
        return o[t.axis][t.name] || new i(t)
    }, n.Group = i
}(), function () {
    "use strict";

    function t(t) {
        this.$element = e(t)
    }

    var e = window.jQuery, i = window.Waypoint;
    e.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], function (e, i) {
        t.prototype[i] = function () {
            var t = Array.prototype.slice.call(arguments);
            return this.$element[i].apply(this.$element, t)
        }
    }), e.each(["extend", "inArray", "isEmptyObject"], function (i, o) {
        t[o] = e[o]
    }), i.adapters.push({name: "jquery", Adapter: t}), i.Adapter = t
}(), function () {
    "use strict";

    function t(t) {
        return function () {
            var i = [], o = arguments[0];
            return t.isFunction(arguments[0]) && (o = t.extend({}, arguments[1]), o.handler = arguments[0]), this.each(function () {
                var n = t.extend({}, o, {element: this});
                "string" == typeof n.context && (n.context = t(this).closest(n.context)[0]), i.push(new e(n))
            }), i
        }
    }

    var e = window.Waypoint;
    window.jQuery && (window.jQuery.fn.waypoint = t(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = t(window.Zepto))
}();
(function ($) {
    "use strict";
    $.fn.counterUp = function (options) {
        var settings = $.extend({
            time: 400,
            delay: 10,
            offset: 100,
            beginAt: 0,
            formatter: false,
            context: "window",
            callback: function () {
            }
        }, options), s;
        return this.each(function () {
            var $this = $(this), counter = {
                time: $(this).data("counterup-time") || settings.time,
                delay: $(this).data("counterup-delay") || settings.delay,
                offset: $(this).data("counterup-offset") || settings.offset,
                beginAt: $(this).data("counterup-beginat") || settings.beginAt,
                context: $(this).data("counterup-context") || settings.context
            };
            var counterUpper = function () {
                var nums = [];
                var divisions = counter.time / counter.delay;
                var num = $(this).attr("data-num") ? $(this).attr("data-num") : $this.text();
                var isComma = /[0-9]+,[0-9]+/.test(num);
                num = num.replace(/,/g, "");
                var decimalPlaces = (num.split(".")[1] || []).length;
                if (counter.beginAt > num) counter.beginAt = num;
                var isTime = /[0-9]+:[0-9]+:[0-9]+/.test(num);
                if (isTime) {
                    var times = num.split(":"), m = 1;
                    s = 0;
                    while (times.length > 0) {
                        s += m * parseInt(times.pop(), 10);
                        m *= 60
                    }
                }
                for (var i = divisions; i >= counter.beginAt / num * divisions; i--) {
                    var newNum = parseFloat(num / divisions * i).toFixed(decimalPlaces);
                    if (isTime) {
                        newNum = parseInt(s / divisions * i);
                        var hours = parseInt(newNum / 3600) % 24;
                        var minutes = parseInt(newNum / 60) % 60;
                        var seconds = parseInt(newNum % 60, 10);
                        newNum = (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds)
                    }
                    if (isComma) {
                        while (/(\d+)(\d{3})/.test(newNum.toString())) {
                            newNum = newNum.toString().replace(/(\d+)(\d{3})/, "$1" + "," + "$2")
                        }
                    }
                    if (settings.formatter) {
                        newNum = settings.formatter.call(this, newNum)
                    }
                    nums.unshift(newNum)
                }
                $this.data("counterup-nums", nums);
                $this.text(counter.beginAt);
                var f = function () {
                    if (!$this.data("counterup-nums")) {
                        settings.callback.call(this);
                        return
                    }
                    $this.html($this.data("counterup-nums").shift());
                    if ($this.data("counterup-nums").length) {
                        setTimeout($this.data("counterup-func"), counter.delay)
                    } else {
                        $this.data("counterup-nums", null);
                        $this.data("counterup-func", null);
                        settings.callback.call(this)
                    }
                };
                $this.data("counterup-func", f);
                setTimeout($this.data("counterup-func"), counter.delay)
            };
            $this.waypoint(function (direction) {
                counterUpper();
                this.destroy()
            }, {offset: counter.offset + "%", context: counter.context})
        })
    }
})(jQuery);
